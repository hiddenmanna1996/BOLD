---
title: Bayesian Ordered Lattice Design for Phase I Clinical Trials
author: Gi-Ming Wang & Curtis Tatsuoka
date: 12/18/2025
output: html_document
runtime: shiny
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA)
```
# Preliminaries
```{r Preliminaries, message = FALSE, warning=FALSE}
library(ggplot2)
library(gridExtra) # Arrange the plots
library(ggbreak) # For axis break
library(dplyr)
library(ggpubr)
library(tidyverse)
library(broom)
library(readxl)
library(scales) # For ggplot segmented bar chart
library(MASS)
library(officer)
library(flextable)
library(tidyverse)
library(png)
library(Iso) # For isotonic regression biviso()
library(shiny) # For GUI (Graphic user interface)
library(shinyMatrix) # For matrix input of GUI (Graphic user interface)
```
# Functions
```{r Functions, message=FALSE, warning=FALSE}
my_function <- function(action, lattice, p_target, ppat_selection, n_stop_total, n_stop_BOLD_1, n_stop_BOLD, prior_information, dlt_prior_input_1_2, dlt_prior_input_1_3, dlt_prior_input_1_4, dlt_prior_input_1_5, dlt_prior_input_2_2, cur_b_1_2, cur_b_1_3, cur_b_1_4, cur_b_1_5, cur_a_2_2, cur_b_2_2, n_p, x_toxic_input_1_2, x_toxic_input_1_3, x_toxic_input_1_4, x_toxic_input_1_5, x_toxic_input_2_2, n_input_1_2, n_input_1_3, n_input_1_4, n_input_1_5, n_input_2_2, pess_input_1_2, pess_input_1_3, pess_input_1_4, pess_input_1_5, pess_input_2_2, threshold_input_1_2_non_informative, threshold_input_1_3_non_informative, threshold_input_1_4_non_informative, threshold_input_1_5_non_informative, threshold_input_2_2_non_informative, threshold_input_1_2_informative, threshold_input_1_3_informative, threshold_input_1_4_informative, threshold_input_1_5_informative, threshold_input_2_2_informative, stage,dlt_true_input_1_2, dlt_true_input_1_3, dlt_true_input_1_4, dlt_true_input_1_5, dlt_true_input_2_2, simulation_runs)
 { #1
  # Specify the current dose level.
  if (lattice=="2x2") # 2x2 combination-drug trial
   { #2
    level_a <- 2
    level_b <- 2
    cur_a <- cur_a_2_2
    cur_b <- cur_b_2_2
   } else #2 Single-drug trial
   { #2
     level_a <- 1
     cur_a <- 1
     if (lattice=="1x2")
      { #3
       level_b <- 2
       cur_b <- cur_b_1_2
      } #3
     if (lattice=="1x3")
      { #3
       level_b <- 3
       cur_b <- cur_b_1_3
       } #3
     if (lattice=="1x4")
      { #3
       level_b <- 4
       cur_b <- cur_b_1_4
      } #3
     if (lattice=="1x5")
      { #3
        level_b <- 5
        cur_b <- cur_b_1_5
      } #3
    } #2
  # Specify prior means.
  if (prior_information=="Non-informative")
   { #2
    dlt_prior <- matrix(p_target,nrow=level_a, ncol=level_b) # Prior mean is set to be the target mean for non-informative prior.
   } else #2
   { #2
    if (lattice=="1x2") {dlt_prior <- matrix(as.numeric(dlt_prior_input_1_2),level_a,level_b)}
    if (lattice=="1x3") {dlt_prior <- matrix(as.numeric(dlt_prior_input_1_3),level_a,level_b)}
    if (lattice=="1x4") {dlt_prior <- matrix(as.numeric(dlt_prior_input_1_4),level_a,level_b)}
    if (lattice=="1x5") {dlt_prior <- matrix(as.numeric(dlt_prior_input_1_5),level_a,level_b)}
    if (lattice=="2x2")
     { #3
      dlt_prior <- matrix(as.numeric(dlt_prior_input_2_2),level_a, level_b)
      dlt_prior[1,] <- matrix(as.numeric(dlt_prior_input_2_2[2,],level_a,level_b)) # For 2x2 lattice, the sequence of level a needs to be reversed.
      dlt_prior[2,] <- matrix(as.numeric(dlt_prior_input_2_2[1,],level_a,level_b))
     } #3
   } #2
  # Specify accumulated number of DLT's.
  if (action=="Conducting")
   { #2
     if (lattice=="1x2") {BOLD_x_count_matrix <- matrix(as.numeric(x_toxic_input_1_2),level_a,level_b)}
     if (lattice=="1x3") {BOLD_x_count_matrix <- matrix(as.numeric(x_toxic_input_1_3),level_a,level_b)}
     if (lattice=="1x4") {BOLD_x_count_matrix <- matrix(as.numeric(x_toxic_input_1_4),level_a,level_b)}
     if (lattice=="1x5") {BOLD_x_count_matrix <- matrix(as.numeric(x_toxic_input_1_5),level_a,level_b)}
     if (lattice=="2x2")
       { #3
        BOLD_x_count_matrix <- matrix(as.numeric(x_toxic_input_2_2),level_a,level_b)
        BOLD_x_count_matrix[1,] <- matrix(as.numeric(x_toxic_input_2_2[2,],level_a,level_b)) # For 2x2 lattice, the sequence of level a needs to be updated
        BOLD_x_count_matrix[2,] <- matrix(as.numeric(x_toxic_input_2_2[1,],level_a,level_b))
       } #3
   } #2
  # Specify accumulated number of treated patients.
  if (action=="Conducting")
   { #2
    if (lattice=="1x2") {BOLD_n_count_matrix <- matrix(as.numeric(n_input_1_2),level_a,level_b)}
    if (lattice=="1x3") {BOLD_n_count_matrix <- matrix(as.numeric(n_input_1_3),level_a,level_b)}
    if (lattice=="1x4") {BOLD_n_count_matrix <- matrix(as.numeric(n_input_1_4),level_a,level_b)}
    if (lattice=="1x5") {BOLD_n_count_matrix <- matrix(as.numeric(n_input_1_5),level_a,level_b)}
    if (lattice=="2x2")
      { #3
       BOLD_n_count_matrix <- matrix(as.numeric(n_input_2_2),level_a,level_b)
       BOLD_n_count_matrix[1,] <- matrix(as.numeric(n_input_2_2[2,],level_a,level_b)) # For a 2x2 lattice, it is necessary to revise the sequence of level a.
       BOLD_n_count_matrix[2,] <- matrix(as.numeric(n_input_2_2[1,],level_a,level_b))
      } #3
   } #2
  # Specify PESS (Prior estimated sample size).
  if (lattice=="1x2") {pess_matrix <- matrix(as.numeric(pess_input_1_2),level_a,level_b)}
  if (lattice=="1x3") {pess_matrix <- matrix(as.numeric(pess_input_1_3),level_a,level_b)}
  if (lattice=="1x4") {pess_matrix <- matrix(as.numeric(pess_input_1_4),level_a,level_b)}
  if (lattice=="1x5") {pess_matrix <- matrix(as.numeric(pess_input_1_5),level_a,level_b)}
  if (lattice=="2x2")
   { #2
    pess_matrix <- matrix(as.numeric(pess_input_2_2),level_a,level_b)
    pess_matrix[1,] <- matrix(as.numeric(pess_input_2_2[2,],level_a,level_b)) # For a 2x2 lattice, it is necessary to revise the sequence of level a.
    pess_matrix[2,] <- matrix(as.numeric(pess_input_2_2[1,],level_a,level_b))
   } #2
  # Specify the threshold for excessively toxic doses.
  if (prior_information=="Non-informative")
   { #2
     if (lattice=="1x2") {threshold_matrix <- matrix(as.numeric(threshold_input_1_2_non_informative),level_a,level_b)}
     if (lattice=="1x3") {threshold_matrix <- matrix(as.numeric(threshold_input_1_3_non_informative),level_a,level_b)}
     if (lattice=="1x4") {threshold_matrix <- matrix(as.numeric(threshold_input_1_4_non_informative),level_a,level_b)}
     if (lattice=="1x5") {threshold_matrix <- matrix(as.numeric(threshold_input_1_5_non_informative),level_a,level_b)}
     if (lattice=="2x2")
       { #3
        threshold_matrix <- matrix(as.numeric(threshold_input_2_2_non_informative),level_a,level_b)
        threshold_matrix[1,] <- matrix(as.numeric(threshold_input_2_2_non_informative[2,],level_a,level_b)) # For a 2x2 lattice, it is necessary to revise the sequence of level a.
        threshold_matrix[2,] <- matrix(as.numeric(threshold_input_2_2_non_informative[1,],level_a,level_b))
     } #3 
   } else #2 For informative prior
   { #2
     if (lattice=="1x2") {threshold_matrix <- matrix(as.numeric(threshold_input_1_2_informative),level_a,level_b)}
     if (lattice=="1x3") {threshold_matrix <- matrix(as.numeric(threshold_input_1_3_informative),level_a,level_b)}
     if (lattice=="1x4") {threshold_matrix <- matrix(as.numeric(threshold_input_1_4_informative),level_a,level_b)}
     if (lattice=="1x5") {threshold_matrix <- matrix(as.numeric(threshold_input_1_5_informative),level_a,level_b)}
     if (lattice=="2x2")
       { #3
        threshold_matrix <- matrix(as.numeric(threshold_input_2_2_informative),level_a,level_b)
        threshold_matrix[1,] <- matrix(as.numeric(threshold_input_2_2_informative[2,],level_a,level_b)) # For 2x2 lattice, the sequence of level a needs to be updated
        threshold_matrix[2,] <- matrix(as.numeric(threshold_input_2_2_informative[1,],level_a,level_b))
     } #3   
   } #2
  # Specify true DLT rates for simulation.
  if (action=="Simulation")
   { #2 
    if (lattice=="1x2") {dlt_true <-  matrix(as.numeric(dlt_true_input_1_2),level_a,level_b)}
    if (lattice=="1x3") {dlt_true <- matrix(as.numeric(dlt_true_input_1_3),level_a,level_b)}
    if (lattice=="1x4") {dlt_true <- matrix(as.numeric(dlt_true_input_1_4),level_a,level_b)}
    if (lattice=="1x5") {dlt_true <- matrix(as.numeric(dlt_true_input_1_5),level_a,level_b)}
    if (lattice=="2x2")
     { #3
      dlt_true <- matrix(as.numeric(dlt_true_input_2_2),level_a, level_b)
      dlt_true[1,] <- matrix(as.numeric(dlt_true_input_2_2[2,],level_a,level_b)) # For a 2x2 lattice, it is necessary to revise the sequence of level a.
      dlt_true[2,] <- matrix(as.numeric(dlt_true_input_2_2[1,],level_a,level_b))
     } #3
  } #2
  # Verify the coherence of the input data.
  check <- 0
  # Check prior means of DLT rates.
    ## Prior means must be positive and less than 1.
  if (all(dlt_prior>0 & dlt_prior<=1)==FALSE)
   { #2
    cat("Prior mean DLT rates must be beween 0 and 1. \n")
    check <- 1
   } #2
    ## prior means must be non-decreasing.
  if (level_a==1)
   { #2
     if (all(diff(dlt_prior[1,])>=0)==FALSE)
      { #3
        cat("Prior mean DLT rates must be non-decreasing. \n")
        check <- 1
      } #3
   } else #2
   { #2
     if (dlt_prior[1,1]>dlt_prior[1,2] |  dlt_prior[1,1]>dlt_prior[2,1] | dlt_prior[1,1]>dlt_prior[2,2] | dlt_prior[1,2]>dlt_prior[2,2] | dlt_prior[2,1]>dlt_prior[2,2])
     { #3
       cat("Prior mean DLT rates must be non-decreasing. \n")
       check <- 1
     } #3
   } #2
  # Check true DLT rates for simulation.
    ## True DLT rates must be positive.
  if (action=="Simulation")
   { #2
     if (all(dlt_true>0 & dlt_true<=1)==FALSE)
       { #3
         cat("True DLT rates cannot be negative or greater than 1. \n")
         check <- 1
       } #3
    ## True DLT rates must be non-decreasing.
  if (level_a==1)
   { #3
     if (all(diff(dlt_true[1,])>=0)==FALSE)
      { #4
        cat("True DLT rates must be non-decreasing. \n")
        check <- 1
      } #4
   } else #3
   { #3
     if (dlt_true[1,1]>dlt_true[1,2] |  dlt_true[1,1]>dlt_true[2,1] | dlt_true[1,1]>dlt_true[2,2] | dlt_true[1,2]>dlt_true[2,2] | dlt_true[2,1]>dlt_true[2,2])
     { #4
       cat("True DLT rates must be non-decreasing. \n")
       check <- 1
     } #4
   } #3
  } #2
  # Check current dose level.
  ## The current dose level for conducting the trial cannot be higher than the highest dose.
  if (action=="Conducting")
   { #2
     if (cur_a>level_a | cur_b>level_b)
      { #3
       cat("Current dose cannot be higher than the highest dose.")
       check<-1
      } #3
  ## The current dose level must be greater than 0.
    if (cur_a<1 | cur_b<1)
      { #3
       cat("Current dose cannot be lower than the lowest dose.")
       check<-1
      } #3
   } #2
   # Check the accumulated number of treated patients.
    ## The accumulated n of the lowest dose cannot be 0 (i.e., trial has to start from the lowest dose)
    if (action=="Conducting")
     { #2
       if (BOLD_n_count_matrix[1,1]==0) 
         { #3
          cat("The sample size of the lowest dose cannot be 0 (i.e., trial has to start from the lowest dose). \n")
          check <- 1
         } #3
   ## Total number of treated patients is capped by 30. 
     if (sum(BOLD_n_count_matrix)>n_stop_total)
       { #3
        cat("Total n must be <=30. \n")
        check <- 1
       } #3 
    } #2
  # Check the accumulated number of DLT's.
  ## Accumulated DLT's of each dose must not be greater than the accumulated n of that dose
   if (action=="Conducting")
    { #2
     if (all(BOLD_x_count_matrix>=0) &                 all(BOLD_x_count_matrix<=BOLD_n_count_matrix)==FALSE)
       { #3
        cat("Accumulated DLT's of each dose cannot be greater than sample size. \n")
        check <- 1
       } #3
   ## Total sum of x cannot be greater than total n
     if (sum(BOLD_x_count_matrix)>sum(BOLD_n_count_matrix))
       { #3
        cat("Total DLT's cannot be greater than total n \n")
        check <- 1
       } #3 
    } #2
  # Check PESS.
   ## PESS of each dose must be between 0 and 12.
   if ((all(pess_matrix>0) & all(pess_matrix<=n_stop_BOLD))==FALSE)
       { #2
        cat("PESS of each dose must be 0<PESS<=12. \n")
        check <- 1
       } #2
  # Check toxicity thresholds.
   ## Threshold of each dose must be between 0 and 1.
   if ((all(threshold_matrix>0) & all(threshold_matrix<1))==FALSE)
       { #2
        cat("Toxicity threshold of each dose must be 0<threshold<1. \n")
        check <- 1
       } #2
  # Check stage(s).
   ## The stages of conducting a clinical trial utilizing a 2x2 lattice design must commence at 1 and progress incrementally by 1 to facilitate the selection of incomparable doses.
   if (action=="Conducting" & lattice=="2x2")
    { #2
     if ((sum(BOLD_n_count_matrix)==3 & stage!=1) | sum(BOLD_n_count_matrix)/n_p!=stage)
       { #3
        cat("For combination-drug trials, \n")
        cat("stage must commence at 1 and progress \n")
        cat("incrementally by 1 to facilitate \n")
        cat("the selection of incomparable doses. \n")
        check <- 1
       } #3
     } #2
  # Set up data structure.
  if (check==0)
   { # Check==0
   a <- list() # List of A levels, where each A level includes all the B levels. We assume the maximum dose level of both drugs (A an B) is 5
  a[[1]] <- data.frame(level_A=c("A1", "A1", "A1", "A1", "A1"), level_B=c("B1", "B2", "B3", "B4", "B5"))
  a[[2]] <- data.frame(level_A=c("A2", "A2", "A2", "A2", "A2"), level_B=c("B1", "B2", "B3", "B4", "B5"))
  a[[3]] <- data.frame(level_A=c("A3", "A3", "A3", "A3", "A3"), level_B=c("B1", "B2", "B3", "B4", "B5"))
  a[[4]] <- data.frame(level_A=c("A4", "A4", "A4", "A4", "A4"), level_B=c("B1", "B2", "B3", "B4", "B5"))
  a[[5]] <- data.frame(level_A=c("A5", "A5", "A5", "A5", "A5"), level_B=c("B1", "B2", "B3", "B4", "B5"))
  # Remove the unused levels of B.
  for (i in 1:level_a)
    {a[[i]]<-a[[i]][c(1:level_b),]}
  # Specify the parameters and statistics.
  for (i in 1:level_a)
   { #2
    for (j in 1:level_b)
     { #3
      a[[i]]$prior_alpha[j] <- dlt_prior[i,j]*pess_matrix[i,j]
      a[[i]]$prior_beta[j] <- pess_matrix[i,j]-a[[i]]$prior_alpha[j]
    } #3
  } #2
  # Start the app (Conducting the trial or running simulations).
  if (action=="Conducting" | action=="Simulation") # Begin to run the app.
   { #2
    if (action=="Simulation" | action=="Conducting")
     { #3
       BOLD_mean_factor <- 100 # A large value as default.
     } #3
    summary_BOLD_administered_count_matrix <- matrix(0,level_a,level_b) # The frequency of being administered for summary purpose.
    summary_BOLD_n_count_matrix <- matrix(0,level_a,level_b) # The frequency of treated patients.
    summary_BOLD_too_toxic_matrix <- matrix(0,level_a,level_b) # The frequency of current doses being overly toxic.
    summary_BOLD_mtd_count_matrix <- matrix(0,level_a,level_b) # The count of doses being identified as MTD.
    BOLD_n_count_total_vector <- vector() # The total number of treated patients for each simulation run.
    if (action=="Conducting")
     { #3
       runs <- 1 # Running for once.
     } else #3
     { #3
       runs <- simulation_runs # Running for iterations.
     } #3
    for (k in 1:runs) 
     { #3 # Loop for simulation runs (only once for conducting clinical trial)
      if (action=="Simulation") # The setting below is only for running simulations.
       { #4
         stage <- 0
         cur_a <- 1 # Initial dose level is the lowest dose.
         cur_b <- 1
         BOLD_x_count_matrix <- matrix(0,level_a,level_b)
         BOLD_n_count_matrix <- matrix(0,level_a,level_b)
         prob_half_up_matrix_final_previous <- matrix(0,level_a,level_b) # The default PPAT of the preceding stage for 2x2 design.
         BOLD_administered_count_matrix <- matrix(0,level_a,level_b)
         BOLD_too_toxic <- matrix(0,level_a,level_b) # Default matrix of overly toxic doses.
         BOLD_not_toxic <- matrix(0,level_a,level_b) # Default matrix of none-toxic current doses.
         BOLD_too_toxic_trace <- matrix(0,level_a,level_b) # Default matrix of overly toxic doses (current doses only, not including any higher level doses).
         BOLD_mtd_contour_matrix <- matrix(0, nrow=level_a, ncol=level_b) # Indicator if a dose is identified as a MTD. 
       } #4
     if (action=="Conducting") # The setting below is only for conducting a clinical trial.
       { #4
         if (lattice=="2x2" & stage==1)
          { #5
           prob_half_up_matrix_final_previous <<- matrix(0,level_a,level_b) # The default PPAT of the preceding stage for 2x2 design.
          } #5
         BOLD_administered_count_matrix <- matrix(0,level_a,level_b)
         BOLD_too_toxic <- matrix(0,level_a,level_b) # Default matrix of overly toxic current doses.
         BOLD_not_toxic <- matrix(0,level_a,level_b) # Default matrix of none-toxic current doses.
         BOLD_too_toxic_trace <- matrix(0,level_a,level_b) # Default matrix of overly toxic doses (current doses only, not including any higher level doses).
         BOLD_mtd_contour_matrix <- matrix(0, nrow=level_a, ncol=level_b) # Indicatoe if a dose is identified as a MTD. 
       } #4
      repeat
       { #4 Loop for stages
         if (action=="Simulation")
          { #5
           stage <- stage + 1
           x_toxic <- rbinom(n=1, size=n_p, prob=dlt_true[cur_a,cur_b]) # Use Binomial distribution to generate DLT's.
           BOLD_x_count_matrix[cur_a,cur_b] <- x_toxic + BOLD_x_count_matrix[cur_a,cur_b] # Add the observed number of toxic number to the total number of toxicity.
           BOLD_n_count_matrix[cur_a,cur_b]<- n_p + BOLD_n_count_matrix[cur_a,cur_b] # Add the number of observed patients to the total number of patients.
           BOLD_administered_count_matrix[cur_a, cur_b] <- BOLD_administered_count_matrix[cur_a, cur_b] + 1 # Record the frequency of being administered.
          } #5
        # Perform dose selection.
         # Set up matrices
        conjugate_prob_above <- matrix(NA, nrow=level_a, ncol=level_b) # CPAT, the conjugate probability of DLT rate being above target.
        prob_half_up_matrix_pava <- matrix(NA, nrow=level_a, ncol=level_b) # PPAT, the posterior probability of DLT rate being above target after PAVA is applied on CPAT.
        # Calculate CPAT
        for (i in 1:level_a)
          { #5
            for (j in 1:level_b)
              { #6
                conjugate_prob_above[i,j] <- 1-pbeta(p_target, shape1=a[[i]]$prior_alpha[j]+BOLD_x_count_matrix[i,j], shape2=a[[i]]$prior_beta[j]+BOLD_n_count_matrix[i,j]-BOLD_x_count_matrix[i,j]) # CPAT
              } #6
          } #5
      # Calculate PPAT by applying PAVA on CPAT
      pava_on_cpat_global <- 0 # "1" means applying global PAVA on the CPAT for PPATA across the whole 2x2 lattice; "0" means applying local PAVA among neighboring doses of 2x2 lattice.
      prob_half_up_matrix_pava <- conjugate_prob_above # Default matrix of PPAT.
      if (level_a==1)
        { #5
          if (cur_b>2)
            { #6
              for (j in 1:(cur_b-2))
                { #7
                   prob_half_up_matrix_pava[cur_a,j]<-0 # Set a very small value for PAVA.
                } #7
            } #6
          if (cur_b<level_b-1)
            { #6
              for (j in (cur_b+2):level_b)
                { #7
                 prob_half_up_matrix_pava[cur_a,j]<-100 # Set a very large value for PAVA
                } #7
            } #6
       BOLD_weight <- vector() # The weights for PAVA.
       for (j in 1:level_b)
         { #6
          BOLD_weight[j] <- BOLD_n_count_matrix[level_a,j] # The weights are the accumulated number of treated patients.
          } #6
      prob_half_up_matrix_pava[level_a,] <- pava(y=prob_half_up_matrix_pava[level_a,],w=BOLD_weight, decreasing=FALSE) # Applying PAVA with weights.
      } else #5 For 2x2
      { #5
        if (pava_on_cpat_global==1) # Applying global PAVA.
         { #6
          prob_half_up_matrix_pava <- biviso(prob_half_up_matrix_pava, weight_matrix) # Weight matrix needs to be specified global PAVA is applied..
         } #6
      if (pava_on_cpat_global==0) # Local PAVA
        # We don't use biviso() for dose selection on 2x2. When the cover dose value with 0 weight is larger than the current dose, it wrongly becomes the current dose value, yet pava() correctly keeps the upper dose value as it is.
       { #6
         weight_column_cur_b <- vector() # The vector of weights for the column of the current dose.
         for (i in 1:level_a)
          { #7
            weight_column_cur_b[i] <- BOLD_n_count_matrix[i,cur_b]
          } #7
         weight_row_cur_a <- vector() # The vector of weights for the row of the current dose.
         for (j in 1:level_b)
          { #7
            weight_row_cur_a[j] <- BOLD_n_count_matrix[cur_a,j]
          } #7
         for (pava_times in 1:100) # Apply PAVA on the row and column of the current doses by iterations.
         { #7
           prob_half_up_matrix_pava[cur_a,] <- pava(prob_half_up_matrix_pava[cur_a,], weight_row_cur_a)
           prob_half_up_matrix_pava[,cur_b] <- pava(prob_half_up_matrix_pava[,cur_b], weight_column_cur_b)
         } # 7
        } #6
      } #5
  prob_half_up_matrix_final <- round(prob_half_up_matrix_pava,3) # PPAT after adjustment with PAVA is rounded to 3 digits.
  if (level_a==2 & level_b==2) # 2x2 design
       { #5 
         if (stage>1 & cur_a==1 & cur_b==2)
           { #6
             prob_half_up_matrix_final[2,1] <- prob_half_up_matrix_final_previous[2,1] # Use the PPAT from the previous PPAT matrix for the diagonal dose of the current dose.
           } #6
        if (stage>1 & cur_a==2 & cur_b==1)
           { #6
             prob_half_up_matrix_final[1,2] <- prob_half_up_matrix_final_previous[1,2]
           } #6
        if (cur_a==1 & cur_b==1)
          { #6
           prob_half_up_matrix_final[2,2] <- 100 # A larger value indicates that the non-neighboring dose will not be the candidate for dose selection.
          } #6
       if (cur_a==2 & cur_b==2)
          { #6
           prob_half_up_matrix_final[1,1] <- 100 # A larger value indicates that the non-neighboring dose will not be the candidate for dose selection.
          } #6
      } #5
   # Overdose control
    excluded_matrix <- matrix(0,level_a,level_b) # Default matrix of excluded doses from trial.
    for (i in 1:level_a)
     { #5
      for (j in 1:level_b)
       { #6
        if (conjugate_prob_above[i,j]>=threshold_matrix[i,j]) # Using CPAT for overdose control.
         { #7
           for (ii in i:level_a)
             { #8
               for (jj in j:level_b)
                 { #9
                   BOLD_too_toxic[ii,jj] <- 1
                   excluded_matrix[ii,jj] <- 1
                 } #9
               } #8
            } #7
        } #6
     } #5
   if (action=="Simulation" & conjugate_prob_above[cur_a,cur_b]>=threshold_matrix[cur_a,cur_b]) # Trace the current doses which are overly toxic.
    { #5 
     for (i in cur_a:level_a) # All the doses above the current dose (including the current dose) will be considered overly toxic if the currenet dose is overly toxic.
      { #6
       for (j in cur_b:level_b)
        { #7
         BOLD_too_toxic_trace[i,j] <- BOLD_too_toxic_trace[i,j]+1
        } #7
      } #6
     } #5
   # Dose selection based on loss function.
    for (i in 1:level_a)
      { #5
       for (j in 1:level_b)
        { #6
          if (is.na(prob_half_up_matrix_final[i,j])==FALSE & excluded_matrix[i,j]!=1 & abs(i-cur_a+j-cur_b)<2) # The dose selection is among the neighborhood doses. In this context, the incomparable dose is also considered a "neighborhood" dose, despite not being adjusted by PAVA in the same manner as the other doses prior to this.
            { #7
              a[[i]]$prob_loss[j] <- abs(prob_half_up_matrix_final[i,j]-ppat_selection) 
            } else #7
            { #7
              a[[i]]$prob_loss[j] <- 100 # Assigning a large value of loss function.
            } #7
         } #6
    } #5
   selected_b <- vector() # Candidate of B levels for each dose level of A.
   for (i in 1:level_a)
     { #5
         xxx <- a[[i]]$prob_loss
         z <- which(xxx==min(xxx)) # There can be a tie.
         if (prob_half_up_matrix_final[i,z[1]]<ppat_selection) # The PPAT of the tie is less than 0.5.
           { #6
             selected_b[i] <- z[length(z)] # Select the highest dose if the tie is less than 0.5.
           } else #6
           { #6
             selected_b[i] <- z[1] # Select the lowest dose if the tie is greater than 0.5.
           } #6
     } #5
    candidates <- vector()
    for (i in 1:level_a)
      { #5
        candidates[i] <- a[[i]]$prob_loss[selected_b[i]]
      } #5
    xxx <- candidates
    zz <- which(xxx==min(xxx)) # There can be a tie.
    if (length(zz)==1)
      { #5
         chosen_a <- zz[1]
      } #5
     if (length(zz)==2) # For 2x2 lattice, there can only be maximum 2 doses being tied.
       { #5
        if (prob_half_up_matrix_final[zz[1],selected_b[zz[1]]]==prob_half_up_matrix_final[zz[2],selected_b[zz[2]]])
         { #6
          if (zz[1]<zz[2] & selected_b[zz[1]]>selected_b[zz[2]]) # Incomparable doses.
           { #7
             if (runif(1,0,1)<0.5) # Coin flip
              { #8
               chosen_a <- zz[1]
              } else #8
              { #8
                chosen_a <- zz[2]
              } #8
           } else #7 Comparable doses.
           { #7
            if (prob_half_up_matrix_final[zz[1],selected_b[zz[1]]]<ppat_selection)
             { #8
               chosen_a <- zz[2] # Select the highest dose if the tie is less than 0.5.
             } else #8
             { #8
               chosen_a <- zz[1] # Select the lowest dose if the tie is greater than 0.5.
             } #8
           } #7
         } else #6 One is less than 0.5 and the other is greater than 0.5.
         { #6
           if (prob_half_up_matrix_final[zz[1],selected_b[zz[1]]]<ppat_selection)
             { #7
               chosen_a <- zz[2] # Select the highest dose.
             } else #7
             { #7
               chosen_a <- zz[1] # Select the lowest dose.
             } #7
         } #6
      } #5
    chosen_b <- selected_b[chosen_a] # Select the final dose level of B.
    if (excluded_matrix[chosen_a,chosen_b]==1) # Check if the chosen dose has been excluded from the trial.
      { #5
        chosen_a <- cur_a # Stay at the current dose.
        chosen_b <- cur_b
      } #5
  # Stopping rules
  # Stopping rule #0: For conducing a clinical trial and not running a simulation.
   stopping_0 <- 0
   if (action=="Conducting")
    { #5    
      stopping_0 <- 1
    } #5
  # Stopping rule #1: The lowest dose is overly toxic.
   stopping <- 0
   stopping_reason <<- 0
  if (BOLD_too_toxic[1,1]==1)
    { #5    
      stopping <- 1
      stopping_reason <<- 1
    } #5
  # Stopping rule #2: Total number of treated patients reaches the ceiling.
   if (sum(BOLD_n_count_matrix)>=n_stop_total)
    { #5
      stopping <- 1
      stopping_reason <<- 2
    } #5
  # Stopping rule #3: The number of treated patients at the current dose reaches the maximum and the decision is to stay at the current dose.
  if (cur_a==1 & cur_b==1)
   { #5
    n_stop_BOLD_new <- n_stop_BOLD_1
   } else #5
   { #5
     n_stop_BOLD_new <- n_stop_BOLD
   } #5
  if (BOLD_n_count_matrix[cur_a,cur_b]>= n_stop_BOLD_new & chosen_a==cur_a & chosen_b==cur_b & excluded_matrix[cur_a,cur_b]==0)
    { #5
       stopping <- 1
       stopping_reason <<- 3
       excluded_matrix[i,j] <- 2 # The dose will not be excluded from the final MTD selection at the end.
    } #5
   # Stopping rule #4 No dose is available to be selected for the next stage.
   test_available <- 0
   for (i in 1:level_a)
     { #5
      for (j in 1:level_b)
       { #6
         if (excluded_matrix[i,j]==0)
           { #7
             test_available <- 1
           } #7
       } #6
     } #5
   if (test_available==0)
    { #5
      stopping <- 1
      stopping_reason <<- 4
    } #5
   if (action=="Conducting")
    { #5
      prob_half_up_matrix_final_previous <<- prob_half_up_matrix_final # Reserve for the next stage on 2x2 design.
    } else #5
    { #5
      prob_half_up_matrix_final_previous <- prob_half_up_matrix_final # Reserve for the next stage on 2x2 design.
    } #5
   if (stopping_0==1 | stopping==1)
       { #5
        break
       } else #5
       { #5
         # Update current dose
          cur_a <- chosen_a # Reset the current dose using the chosen dose.
          cur_b <- chosen_b
       } #5
     } #4 Loop end for stages
    # MTD identification
    if (stopping==1) # Identify MTD only if any criterion of general stopping rules is met.
    { #4
    # Calculate the conjugate mean DLT rates.
     pava_on_conjugate_global <- 1 # "1" means applying global PAVA on the conjugate mean across the whole 2x2 lattice; "0" meansn applying local PAVA among neighboring doses of 2x2 lattice.
     BOLD_mean_matrix <- matrix(NA, level_a, level_b) # Set up the matrix of poster mean DLT rates.
     for (i in 1:level_a)
      { #5
        for (j in 1:level_b)
          { #6
           BOLD_mean_matrix[i,j] <- (a[[i]]$prior_alpha[j]+BOLD_x_count_matrix[i,j])/(a[[i]]$prior_alpha[j]+a[[i]]$prior_beta[j]+BOLD_n_count_matrix[i,j]) 
          } #6
      } #5
    # Apply PAVA on conjugate means.
    BOLD_mean_pava <- BOLD_mean_matrix # Default matrix.
    if (level_a==1) # For single-drug trial.
     { #5
       BOLD_weight <- vector() # The weights for PAVA.
       for (j in 1:level_b)
         { #6
          BOLD_weight[j] <- BOLD_n_count_matrix[level_a,j]
         } #6
       BOLD_mean_pava[1,] <- round(pava(BOLD_mean_pava[1,],BOLD_weight),3) # Rounding is needed, for the tiny difference between two values after PAVA should be ignored. The two values which are very close to each other after PAVA should be considered equal.
    } else #5 For combined-drug trials.
    { #5
    if (pava_on_conjugate_global==1) # Apply global PAVA using biviso(). 
     { #6
       weight_matrix <- matrix(NA, nrow=level_a, ncol=level_b)
       for (i in 1:2) # Only applied for 2x2 lattice.
         { #7
          weight_matrix[i,] <- BOLD_n_count_matrix[i,]+pess_matrix[i,] # To avoid zero weight for biviso().
         } #7
    BOLD_mean_pava <- round(biviso(BOLD_mean_pava, weight_matrix),3)
     } #6
    if (pava_on_conjugate_global==0) # Applying local PAVA on neighboring doses. 
    { #6
     # Apply PAVA on the column of the current dose.
     weight_column_cur_b <- vector()
     for (i in 1:level_a)
      { #7
       weight_column_cur_b[i] <- BOLD_n_count_matrix[i,cur_b]
      } #7
    # Apply PAVA on the row of the current dose.
    weight_row_cur_a <- vector()
    for (j in 1:level_b)
     { #7
      weight_row_cur_a[j] <- BOLD_n_count_matrix[cur_a,j]
     } #7
    for (pava_times in 1:100)
     { #7
      BOLD_mean_pava[cur_a,] <- round(pava(BOLD_mean_pava[cur_a,], weight_row_cur_a),3)
      BOLD_mean_pava[,cur_b] <- round(pava(BOLD_mean_pava[,cur_b], weight_column_cur_b),3)
     } #7
   if (stage>1 & level_a==2 & level_b==2)
     { #7
        if (cur_a==1 & cur_b==2)
           { #8
             BOLD_mean_pava[2,1] <- BOLD_mean_pava_previous[2,1] # Use the posterior mean from the previous matrix for the diagonal dose of the current dose instead of using its conjugate mean.
           } #8
        if (cur_a==2 & cur_b==1)
           { #8
             BOLD_mean_pava[1,2] <- BOLD_mean_pava_previous[1,2]
           } #8
      } #7
     BOLD_mean_pava_previous <- BOLD_mean_pava
    } #6
  } #5
  # Exclude the non-candidates of MTD.
  for (i in 1:level_a)
   { #5
    for (j in 1:level_b)
     { #6
       if (abs(i-cur_a+j-cur_b)>=2 | BOLD_n_count_matrix[i,j]==0 | excluded_matrix[i,j]==1 | BOLD_mean_pava[i,j]>(1+BOLD_mean_factor)*p_target) # Exclude the dose which is neither neighboring dose nor incomparable dose, without trial data, having been eliminated from MTD candidates, or whose posterior mean after PAVA is greater than the (1+BOLD_mean_factor)*p_target, which is the acceptable upper limit.
        { #7
          BOLD_mean_pava[i,j] <- 100
        } #7
     } #6
  } #5
   # Select the dose(s) across the whole lattice whose posterior mean after PAVA is (are) nearest to the target rate.
    BOLD_mtd_contour_matrix_candidates <- matrix(0, nrow=level_a, ncol=level_b) # Indicate if a dose is identified as a MTD candidate.
   if (BOLD_too_toxic[1,1]==0) # We identify the MTD only when the lowest dose is not too toxic.
   { #5
     selected_b <- vector() # Candidate of B levels for each dose level of A.
     for (i in 1:level_a)
      { #6
        t <- abs(BOLD_mean_pava[i,]-p_target)
        candidate_index <- which(t==min(t)) # There can be ties among those values nearest to the target rate.
       if (BOLD_mean_pava[i,candidate_index[1]] < p_target)
         { #7
           if (BOLD_mean_pava[i,candidate_index[length(candidate_index)]] < p_target) # If the lower tie is less than target and the higher tie is also less than target, we identify the higher dose.
            { #8
             selected_b[i] <- candidate_index[length(candidate_index)] # Choose the highest dose level among the ties
            } else #8 If the lower tie is less than target and the higher tie is greater than target, then we identify the lower dose.
            { #8
             selected_b[i] <- candidate_index[1] # Choose the lowest dose level among the ties
            } #8
     } else #7 If the lower tie is greater than the target
     { #7
       selected_b[i] <- candidate_index[1] # Choose the lowest dose level among the ties
     } #7
  } #6
  candidates <- vector()
  for (i in 1:level_a)
   { #6
   candidates[i] <- BOLD_mean_pava[i,selected_b[i]]
   } #6
  tt <- abs(candidates-p_target)
  candidate_MTD_a <- which(tt==min(tt)) # Select the final dose level of A from the candidates. There can be more than one result if there is a tie.
  candidate_MTD_b <- selected_b[candidate_MTD_a] # Select the final dose level of B.
  BOLD_mtd_contour_matrix_candidates[candidate_MTD_a, candidate_MTD_b] <- 1
 } #5
  # Identify the final unique MTD.
  if (BOLD_too_toxic[1,1]==1 | sum(BOLD_mtd_contour_matrix_candidates)==0) # Check if there is no MTD identification. 
 { #5
  BOLD_final_MTD_a <- NA
  BOLD_final_MTD_b <- NA
 } else #5
 { #5
  if (sum(BOLD_mtd_contour_matrix_candidates)==1) # If there is only one MTD
   { #6
    for (i in 1:level_a)
    { #7
      for (j in 1:level_b)
       { #8
        if (BOLD_mtd_contour_matrix_candidates[i,j]==1)
         { #9
          BOLD_final_MTD_a <- i
          BOLD_final_MTD_b <- j
         } #9
      } #8
    } #7
  } #6
  if (sum(BOLD_mtd_contour_matrix_candidates)>1) # If there is a tie.
   { #6
    if (candidate_MTD_a[1]==1 & candidate_MTD_b[1]==2 & candidate_MTD_a[2]==2 & candidate_MTD_b[2]==1) # Check if the tie occurs between the incomparable doses (for 2x2 only).
    { #7
      if (BOLD_n_count_matrix[1,2]==BOLD_n_count_matrix[2,1]) # Check if the incomparable doses have the same number of treated patients.
        { #8
         if (runif(1,0,1)<0.5) # Flip a coin.
          { #9
           BOLD_final_MTD_a <- 1
           BOLD_final_MTD_b <- 2
          } else #9
          { #9
            BOLD_final_MTD_a <- 2
            BOLD_final_MTD_b <- 1
          } #9
        } else #8 We will identify the one with more treated patient between the incomparable doses.
        { #8
         number_n <- rep(0, level_a)
         for (i in 1:level_a)
           { #9
             for (j in 1:level_b)
              { #10
               if (BOLD_mtd_contour_matrix_candidates[i,j]==1)
                 { #11
                  number_n[i] <- BOLD_n_count_matrix[i,j]
                 } #11
              } #10
           } #9
        BOLD_final_MTD_a <- which.max(number_n)
        for (j in 1:level_b)
         { #9
           if (BOLD_mtd_contour_matrix_candidates[BOLD_final_MTD_a,j]==1)
             { #10
                BOLD_final_MTD_b <- j
             } #10
         } #9
      } #8
   } else #7 The tie is among the comparable doses.
   { #7
     if (BOLD_mean_pava[candidate_MTD_a[1],candidate_MTD_b[1]]>p_target)
      { #8
        BOLD_final_MTD_a <- candidate_MTD_a[1]
        BOLD_final_MTD_b <- candidate_MTD_b[1]
      } else #8
      { #8
        BOLD_final_MTD_a <- candidate_MTD_a[2]
        BOLD_final_MTD_b <- candidate_MTD_b[2]
      } #8
    } #7
   } #6
  BOLD_mtd_contour_matrix[BOLD_final_MTD_a,BOLD_final_MTD_b] <- 1
  } #5
  BOLD_final_MTD_pseudo <- NA
  if (is.na(BOLD_final_MTD_b)==TRUE) # Check if there is no MTD identification.
   { #5
    if (BOLD_too_toxic[1,1]==1)
     { #6
      BOLD_final_MTD_pseudo <- "Lower pseudo dose" # Lower pseudo dose is identified.
     } #6
    if (BOLD_not_toxic[level_a,level_b]==1)
     { #6
      BOLD_final_MTD_pseudo <- "Upper pseudo dose" # Upper pseudo dose is identified.
     } #6
    if (action=="Simulation")
     { #6
      if (dlt_true[level_a,level_b]<=p_target) # For simulations, if true DLT rate is less than or equal to the target rate, the highest dose will be identified as the MTD.
       { #7
         BOLD_mtd_contour_matrix[level_a,level_b] <- 1
       } #7
     } #6
   } #5
  } #4
  # Summarize the statistics up to the kth simulation run
   summary_BOLD_too_toxic_matrix <- summary_BOLD_too_toxic_matrix + BOLD_too_toxic_trace # Matrix of total numbers of overly toxic doses up to the kth simulation run.
   summary_BOLD_administered_count_matrix <- summary_BOLD_administered_count_matrix + BOLD_administered_count_matrix # Matrix of total numbers of doses being administered up to the kth simulation run.
   BOLD_n_count_total_vector[k] <- sum(BOLD_n_count_matrix) # Vector of total number of treated patients per trial up to the kth simulation run.
   summary_BOLD_n_count_matrix <- summary_BOLD_n_count_matrix + BOLD_n_count_matrix # Matrix of total numbers of patients up to the kth simulation run.
   summary_BOLD_mtd_count_matrix <- summary_BOLD_mtd_count_matrix + BOLD_mtd_contour_matrix # Matrix of total frequencies of MTD identifications up to the kth simulation run.
  } #3 Iteration end for simulation runs or conducting only one trial.
  # Print trial output or simulation result.
  if (action=="Conducting") 
   { #3
    cat("\n Number of treated patients :\n")
     if (lattice=="1x2")  {cat(BOLD_n_count_matrix[,c(1:2)],"\n")}
     if (lattice=="1x3") {cat(BOLD_n_count_matrix[,c(1:3)],"\n")}
     if (lattice=="1x4") {cat(BOLD_n_count_matrix[,c(1:4)],"\n")}
     if (lattice=="1x5") {cat(BOLD_n_count_matrix[,c(1:5)],"\n")}
     if (lattice=="2x2")
      { #4
       cat("A2 (B1 B2) : ", BOLD_n_count_matrix[2,],"\n")
       cat("A1 (B1 B2) : ", BOLD_n_count_matrix[1,],"\n")
      } #4
   cat("\n Number of DLT's :","\n")
     if (lattice=="1x2") {cat(BOLD_x_count_matrix[,c(1:2)],"\n")}
     if (lattice=="1x3") {cat(BOLD_x_count_matrix[,c(1:3)],"\n")}
     if (lattice=="1x4") {cat(BOLD_x_count_matrix[,c(1:4)],"\n")}
     if (lattice=="1x5") {cat(BOLD_x_count_matrix[,c(1:5)],"\n")}
     if (lattice=="2x2")
       { #4
        cat("A2 (B1 B2) : ", BOLD_x_count_matrix[2,],"\n")
        cat("A1 (B1 B2) : ", BOLD_x_count_matrix[1,],"\n")
       } #4
    if (stopping==0 | stopping==1)  
     { #4
      # Print PPATs
      for (i in 1:level_a)
       { #5
        for (j in 1:level_b)
         { #6
          if (prob_half_up_matrix_final[i,j]==0 | prob_half_up_matrix_final[i,j]>1)
           { #7
            prob_half_up_matrix_final[i,j] <- NA
           } #7
         } #6
       } #5
      cat("\n Posterior probabilities of DLT rates being above \n")
      cat("target rate (PPATs), where NA means non-neighborhood dose:","\n")
      if (lattice=="1x2")   {cat(prob_half_up_matrix_final[,c(1:2)],"\n")}
      if (lattice=="1x3") {cat(prob_half_up_matrix_final[,c(1:3)],"\n")}
      if (lattice=="1x4") {cat(prob_half_up_matrix_final[,c(1:4)],"\n")}
      if (lattice=="1x5") {cat(prob_half_up_matrix_final[,c(1:5)],"\n")}
      if (lattice=="2x2")
        { #5
          cat("A2B1 A2B2 : ", prob_half_up_matrix_final[2,],"\n")
          cat("A1B1 A1B2 : ", prob_half_up_matrix_final[1,],"\n")
        } #5
      # Print indicators of overly toxic doses
      cat("\n Whether the dose is overly toxic (0:no; 1:yes): \n")
      if (level_a==1)
       { #5
        cat(BOLD_too_toxic,"\n")
       } else #5
       { #5
        cat("A2B1 A2B2 : ", BOLD_too_toxic[2,],"\n")
        cat("A1B1 A1B2 : ", BOLD_too_toxic[1,],"\n")
       } #5
    } #4
  # Print the dose selection.
    if (stopping==0)
     { #4
      cat("\n Next dose selection : ")
       if (level_a==1)
         { #5
          cat("Level ", chosen_b, "\n")
         } else #5
         { #5 
           cat("(A,B) = (",chosen_a,",", chosen_b,") \n")
         } #5
      } #4
     if (stopping==1) # We identify the MTD while conducting a clinical trial only when the stopping rule is met.
     { #4
      # Print the reason for the trial to be halted.
       if (stopping_reason==1)
        { #5
         cat("\n The trial was halted due to the \n")
         cat("excessive toxicity of the lowest dose.\n")
        } #5
       if (stopping_reason==2)
        { #5
         cat("\n The trial was halted as the total number \n")
         cat("of patients treated reached its limit.\n")
        } #5
       if (stopping_reason==3)
        { #5
         cat("\n The trial was halted upon reaching the maximum  \n")
         cat("number of patients per dose and the decision \n")
         cat("is to maintain the current dose. \n")
        } #5
       if (stopping_reason==4)
        { #5
         cat("\n The trial was halted due to the \n")
         cat("unavailability of a selectable dose.  \n")
        } #5
       # Print the posterior mean DLT rates
       for (i in 1:level_a)
        { #5
         for (j in 1:level_b)
          { #6
           if (BOLD_mean_pava[i,j]==100)
            { #7
             BOLD_mean_pava[i,j] <- NA
            } #7
          } #6
        } #5
      cat("\n The posterior mean DLT rates (NA means not a MTD candidate):","\n")
      if (lattice=="1x2") {cat(BOLD_mean_pava[,c(1:2)],"\n")}
      if (lattice=="1x3") {cat(BOLD_mean_pava[,c(1:3)],"\n")}
      if (lattice=="1x4") {cat(BOLD_mean_pava[,c(1:4)],"\n")}
      if (lattice=="1x5") {cat(BOLD_mean_pava[,c(1:5)],"\n")}
      if (lattice=="2x2")
        { #5
          cat("A2", BOLD_mean_pava[2,],"\n")
          cat("A1", BOLD_mean_pava[1,],"\n")
        } #5
      # Print MTD identification.
      cat("\n MTD identification : ")
      if (is.na(BOLD_final_MTD_a)==FALSE)
         { #5
           if (level_a==1)
            { #6
             cat("Level ", BOLD_final_MTD_b,"\n")
            } else #6
            { #6
             cat("(A,B) = (",BOLD_final_MTD_a,",", BOLD_final_MTD_b,") \n")
            } #6
        } else #5 No MTD identification
        { #5
         cat(BOLD_final_MTD_pseudo,"\n")
        } #5
    } else #4
    { #4
      cat("\n The trial for MTD identification is still ongoing.")
    } #4
  } #3       
 if (action=="Simulation")
   { #3
    # Print the average frequencies of administered doses.
     cat("\n Average frequencies of administered doses: \n")
     if (level_a==1)
       { #4
         cat(round(summary_BOLD_administered_count_matrix/k,2),"\n")
        } else #4
        { #4
         cat("A2B1 A2B2 : ", round(summary_BOLD_administered_count_matrix[2,]/k,2),"\n")
         cat("A1B1 A1B2 : ", round(summary_BOLD_administered_count_matrix[1,]/k,2),"\n")
        } #4
    # Print the percentages of MTD identification.
    cat("\n Percentages of MTD identification : \n")
    if (level_a==1)
      { #4
        cat(round(summary_BOLD_mtd_count_matrix/k,2),"\n")
      } else #4
      { #4
       cat("A2B1 A2B2 : ", round(summary_BOLD_mtd_count_matrix[2,]/k,2),"\n")
    cat("A1B1 A1B2 : ", round(summary_BOLD_mtd_count_matrix[1,]/k,2),"\n")
      } #4
   # Print the average number of treated patients.
   cat("\n Average number of treated patients : \n")
   cat(round(sum(summary_BOLD_n_count_matrix, na.rm=TRUE)/k,2),"\n")
    # Print the standard deviation of the number of treated patients.
    cat("\n SD of the number of treated patients : \n")
    cat(round(sd(BOLD_n_count_total_vector, na.rm=TRUE),2),"\n")
   # Print the probabilities of being overly toxic.
    cat("\n Probabilities of the doses being overly toxic: \n")
    if (level_a==1)
       { #4
         cat(round(summary_BOLD_too_toxic_matrix/k,2),"\n")
       } else #4
       { #4
         cat("A2B1 A2B2 : ", round(summary_BOLD_too_toxic_matrix[2,]/k,2),"\n")
         cat("A1B1 A1B2 : ", round(summary_BOLD_too_toxic_matrix[1,]/k,2),"\n")
        } #4       
    } #3
  } #2 End of starting App
 } # End of Check==0
} #1
```
# Setting for input
```{r settings, message=FALSE, warning=FALSE}
action_list <- c("Conducting", "Simulation") # Either conducting a clinical trial or running a simulation
# choice <- c("1x2", "1x3", "1x4", "1x5", "2x2") # Choice of dose matrix
choice <- c("1x2", "1x3", "1x4", "1x5") # Choice of dose matrix
# target <- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3) # Possible target rate of DLT.
dose_level_a1_b2 <- c(1,2) # For the input of the dose level of the current dose for single-drug trial of 1x2 lattice.
dose_level_a1_b3 <- c(1,2,3) # For the input of the dose level of the current dose for single-drug trial of 1x3 lattice.
dose_level_a1_b4 <- c(1,2,3,4) # For the input of the dose level of the current dose for single-drug trial of 1x4 lattice.
dose_level_a1_b5 <- c(1,2,3,4,5) # For the input of the dose level of the current dose for single-drug trial of 1x5 lattice.
dose_level_a2_b2_a <- c(1,2) # For the input of the dose level A of the current dose for combined-drug trial.
dose_level_a2_b2_b <- c(1,2) # For the input of the dose level B of the current dose for combined-drug trial.
treated_patients <- c(1,2,3,4,5) # Cohort size for each stage of trial.
observed_dlt <- c(0,1,2,3) # Possible observed number of DLT's.
n_stop_BOLD <- c(6,7,8,9,10,11,12,13,14,15) # Maximum number of treated patients per dose.
n_stop_total <- c(21,24,27,30,33,36,39) # Maximum total number of treated patients.
prior_information_list <- c("Non-informative", "Informative") # Whether prior information is informative or non-informative
stage_list <- c(1,2,3,4,5,6,7,8,9,10) # The stage number with maximum 10 stges.
BOLD_mean_factor_list <- c(0.4,100)
simulation_runs_list <- c(100, 500, 1000, 2000, 5000, 10000)
```
# Shiny user interface
```{r user_interface, message=FALSE, warning=FALSE}
ui <- bslib::page_sidebar(
  titlePanel("Bayesian Ordered Lattice Design for Phase I Clinical Trials"),
  helpText(
      "This application has been created by Gi-Ming Wang and Curtis Tatsuoka with the objective of assisting in dose selection and MTD identification."
    ),
  sidebar = bslib::sidebar(
  width=650, # The width of the sidebar at the left hand side.
  selectInput("action", label="Do you want to conduct a clinical trial (select 'Conducting') or run a simualtion (select 'Simulation')?", selected = "Conducting", action_list), # "selected" means that it will be automatically selected if the user does not make selection. The user can choose either to conduct a clinical trial or run a simulation.
  selectInput("lattice", label="What's the lattice of dose levels? (Default lattice is 1x5)", selected = "1x5", choice), # Choose the drug lattice.
  sliderInput("p_target", label="What is the target DLT rate? (Default value is 0.25)", min=0.1, max=0.3, value=0.25, step = 0.01),
  sliderInput("ppat_selection", label="What is the PPAT threshold parameter? (Default value is 0.5)", min=0.45, max=0.55, value=0.5, step = 0.01),
  sliderInput("n_p", "What is the number of treated patients per stage of trial? (Default value is 3)", min=1, max=10, value=3, step = 1),
  sliderInput("n_stop_BOLD_1", label="What is the maximum number of treated patients at the lowest dose for early stop? (Default value is 15)", min=1, max=30, value=15, step=1),
  sliderInput("n_stop_BOLD", label="What is the maximum number of treated patients at other doses for early stop? (Default value is 12)", min=1, max=30, value=12, step=1),
  sliderInput("n_stop_total", label="What is the maximum nubmer of total treated patients? (Default value is 30)", min=10, max=100, value=30, step=1),
  # Input prior means for trials with informative priors
   selectInput("prior_information", label="What is the prior information of toxicity (Non-informative or informative)?", selected = "Non-informative", prior_information_list), # The default is non-informative prior.
   conditionalPanel(
      condition = c("input.lattice == '1x2' & input.prior_information=='Informative'"),
matrixInput(
  "dlt_prior_input_1_2",
  label="Please input the prior mean DLT rates (Default values are 0.2 and 0.4 for dose 1 and 2):",
  value = matrix(c(0.2, 0.4), 1, 2, byrow=TRUE, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = c("input.lattice == '1x3' & input.prior_information=='Informative'"),
matrixInput(
  "dlt_prior_input_1_3",
  label="Please input the prior mean DLT rates (Default values are 0.2, 0.3 and 0.4 for dose 1, 2 and 3):",
  value = matrix(c(0.2,0.3,0.4), 1, 3, byrow=TRUE, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = c("input.lattice == '1x4' & input.prior_information=='Informative'"),
matrixInput(
  "dlt_prior_input_1_4",
  label="Please input the prior mean DLT rates (Default values are 0.1, 0.2, 0.3 and 0.4 for dose 1, 2, 3 and 4):",
  value = matrix(c(0.1,0.2,0.3,0.4), 1, 4, byrow=TRUE, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = c("input.lattice == '1x5' & input.prior_information=='Informative'"),
matrixInput(
  "dlt_prior_input_1_5",
  label="Please input the prior mean DLT rates (Default values are 0.1, 0.2, 0.3, 0.4 and 0.5 for dose 1, 2, 3, 4 and 5)",
  value = matrix(c(0.1,0.2,0.3,0.4,0.5), 1, 5, byrow=TRUE, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = c("input.lattice == '2x2' & input.prior_information=='Informative'"),
matrixInput(
  "dlt_prior_input_2_2",
  label="Please input the prior mean DLT rates (Default values are 0.1, 0.2, 0.2 and 0.3 for A1B1, A1B2, A2B1 and A2B2)",
  value = matrix(c(0.2, 0.3, 0.1, 0.2), 2, 2, byrow=TRUE, dimnames = list(c("A2", "A1"), c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
 # Input PESS :
  conditionalPanel(
      condition = "input.lattice == '1x2'",
matrixInput(
  "pess_input_1_2",
  label="Please provide the prior estimated sample sizes (PESS), defined as the sum of alpha and beta for the prior Beta distribution of DLT rate, with the default value set at 3 :",
  value = matrix(3, 1, 2, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x3'",
matrixInput(
  "pess_input_1_3",
  label="Please provide the prior estimated sample sizes (PESS), defined as the sum of alpha and beta for the prior Beta distribution of DLT rate, with the default value set at 3 :",
  value = matrix(3, 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x4'",
matrixInput(
  "pess_input_1_4",
  label="Please provide the prior estimated sample sizes (PESS), defined as the sum of alpha and beta for the prior Beta distribution of DLT rate, with the default value set at 3 :",
  value = matrix(3, 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x5'",
matrixInput(
  "pess_input_1_5",
  label="Please provide the prior estimated sample sizes (PESS), defined as the sum of alpha and beta for the prior Beta distribution of DLT rate, with the default value set at 3 :",
  value = matrix(3, 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '2x2'",
matrixInput(
  "pess_input_2_2",
  label="Please provide the prior estimated sample sizes (PESS), defined as the sum of alpha and beta for the prior Beta distribution of DLT rate, with the default value set at 3 :",
  value = matrix(3, 2, 2, dimnames = list(c("A2", "A1"), c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  # Input toxicity threshold.
  ## For non-informative prior.
  conditionalPanel(
      condition = "input.lattice == '1x2' & input.prior_information=='Non-informative'",
matrixInput(
  "threshold_input_1_2_non_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95), 1, 2, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x3' & input.prior_information=='Non-informative'",
matrixInput(
  "threshold_input_1_3_non_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95), 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x4' & input.prior_information=='Non-informative'",
matrixInput(
  "threshold_input_1_4_non_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95,0.95), 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
   conditionalPanel(
      condition = "input.lattice == '1x5' & input.prior_information=='Non-informative'",
matrixInput(
  "threshold_input_1_5_non_informative",
   label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95,0.95,0.95), 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '2x2' & input.prior_information=='Non-informative'",
matrixInput(
  "threshold_input_2_2_non_informative",
   label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.95,0.95,0.9,0.95), 2, 2, byrow=TRUE, dimnames = list(c("A2","A1"), c("B1", "B2"))), 
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  ## For informative prior
  conditionalPanel(
      condition = "input.lattice == '1x2' & input.prior_information=='Informative'",
matrixInput(
  "threshold_input_1_2_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95), 1, 2, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x3' & input.prior_information=='Informative'",
matrixInput(
  "threshold_input_1_3_informative",
 label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95), 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x4' & input.prior_information=='Informative'",
matrixInput(
  "threshold_input_1_4_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95,0.95), 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
   conditionalPanel(
      condition = "input.lattice == '1x5' & input.prior_information=='Informative'",
matrixInput(
  "threshold_input_1_5_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95,0.95,0.95), 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '2x2' & input.prior_information=='Informative'",
matrixInput(
  "threshold_input_2_2_informative",
 label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95,0.95), 2, 2, byrow=TRUE, dimnames = list(c("A2","A1"), c("B1", "B2"))), 
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
 # Input posterior mean factor.
  # conditionalPanel(
  #     condition = "input.action == 'Conducting'", # In the context of clinical trials, we exclusively establish the posterior mean factor; this practice does not extend to the execution of simulations, as the results from these simulations are intended for comparison with alternative designs, including the 3+3 and BOIN. 
  #    selectInput("BOLD_mean_factor", label="What is the posterior mean factor m? (The posterior mean DLT rate of MTD candidates cannot be greater than [1+m] x target, with default value m=0.4)", selected = 0.4, BOLD_mean_factor_list)), 
  # Input stage number.
  conditionalPanel(
      condition = "input.action == 'Conducting'", 
      selectInput("stage_input", label="What is the current stage number? (The stage for combination-drug trial must begin with 1 and continue thereafter)", selected = 1, stage_list)), # The default is stage 1.
   # Input current dose level being administered.
  conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '1x2'",
    selectInput("cur_b_1_2", "What is the dose level being currently administered?", selected =1, dose_level_a1_b2)
    ),
  conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '1x3'",
    selectInput("cur_b_1_3", "What is the dose level being currently administered?", selected =1, dose_level_a1_b3)
    ),
 conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '1x4'",
    selectInput("cur_b_1_4", "What is the dose level being currently administered?", selected =1, dose_level_a1_b4)
    ),
  conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '1x5'",
    selectInput("cur_b_1_5", "What is the dose level being currently administered?", selected =1, dose_level_a1_b5)
    ),
   conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '2x2'",
    selectInput("cur_a_2_2", "What is the dose level of drug A being currently administered?", selected =1, dose_level_a2_b2_a)
    ),
   conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '2x2'",
    selectInput("cur_b_2_2", "What is the dose level of drug B being currently administered?", selected =1, dose_level_a2_b2_b)
    ), 
  # Input accumulated numbers of DLT's.
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x2'",
matrixInput(
  "x_toxic_input_1_2",
  label="Please input the numbers of accumulated DLT's :",
  value = matrix(0, 1, 2, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x3'",
matrixInput(
  "x_toxic_input_1_3",
  label="Please input the numbers of accumulated DLT's :",
  value = matrix(0, 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x4'",
matrixInput(
  "x_toxic_input_1_4",
  label="Please input the numbers of accumulated DLT's :",
  value = matrix(0, 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x5'",
matrixInput(
  "x_toxic_input_1_5",
  label="Please input the numbers of accumulated DLT's :",
  value = matrix(0, 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '2x2'",
matrixInput(
  "x_toxic_input_2_2",
  label="Please input the numbers of accumulated DLT's :",
  value = matrix(0, 2, 2, dimnames = list(c("A2", "A1"), c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
 # Input accumulated numbers of treated patients.
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x2'",
matrixInput(
  "n_input_1_2",
  label="Please input the accumulated numbers of treated patients :",
  value = matrix(c(3,0), 1, 2, dimnames = list("A1", c("B1", "B2"))), # The first n cannot be zero, otherwise there will be error with the weighting factors in PAVA.
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x3'",
matrixInput(
  "n_input_1_3",
  label="Please input the accumulated numbers of treated patients :",
  value = matrix(c(3,0,0), 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x4'",
matrixInput(
  "n_input_1_4",
  label="Please input the accumulated numbers of treated patients :",
  value = matrix(c(3,0,0,0), 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x5'",
matrixInput(
  "n_input_1_5",
  label="Please input the accumulated numbers of treated patients :",
  value = matrix(c(3,0,0,0,0), 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '2x2'",
matrixInput(
  "n_input_2_2",
  label="Please input the accumulated numbers of treated patients :",
  value = matrix(c(0,0,3,0), 2, 2, byrow=TRUE, dimnames = list(c("A2", "A1"), c("B1", "B2"))), # Note that n of A1B1 is 3, which appears at the 3rd place in the vector rather than the 1st place.
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
# Input true DLT rates for simulation.
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.lattice == '1x2'",
matrixInput(
  "dlt_true_input_1_2",
  label="Please input the non-descending true DLT rates for simulation (Target rate may be used as the default value):",
  value = matrix(c(0,0), 1, 2, dimnames = list("A1", c("B1", "B2"))),   rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.lattice == '1x3'",
matrixInput(
  "dlt_true_input_1_3",
  label="Please input the non-descending true DLT rates for simulation (Target rate may be used as the default value):",
  value = matrix(c(0,0,0), 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.lattice == '1x4'",
matrixInput(
  "dlt_true_input_1_4",
  label="Please input the non-descending true DLT rates for simulation (Target rate may be used as the default value):",
  value = matrix(c(0,0,0,0), 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.lattice == '1x5'",
matrixInput(
  "dlt_true_input_1_5",
  label="Please input the non-descending true DLT rates for simulation (Target rate may be used as the default value):",
  value = matrix(c(0,0,0,0,0), 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.lattice == '2x2'",
matrixInput(
  "dlt_true_input_2_2",
  label="Please input the non-descending true DLT rates for simulation (Target rate may be used as the default value):",
  value = matrix(c(0,0,0,0), 2, 2, byrow=TRUE, dimnames = list(c("A2", "A1"), c("B1", "B2"))), 
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
 # Input the number of simulation runs.
  conditionalPanel(
     condition = "input.action == 'Simulation'", 
     selectInput("simulation_runs", label="What is the number of simulation runs? (Default value is 1,000)", selected = 1000, simulation_runs_list)),
  # Button of action (running).
  actionButton("Submit", "Start"),
   verbatimTextOutput("result")
  )
 )
```
# Shiny server program
```{r server, message=FALSE, warning=FALSE}
server <- function(input, output)
 { #1
  result <- eventReactive(input$Submit, {
  my_function(as.character(input$action), as.character(input$lattice), as.numeric(input$p_target), as.numeric(input$ppat_selection), as.numeric(input$n_stop_total), as.numeric(input$n_stop_BOLD_1), as.numeric(input$n_stop_BOLD), as.character(input$prior_information), as.matrix(input$dlt_prior_input_1_2), as.matrix(input$dlt_prior_input_1_3), as.matrix(input$dlt_prior_input_1_4), as.matrix(input$dlt_prior_input_1_5), as.matrix(input$dlt_prior_input_2_2), as.numeric(input$cur_b_1_2), as.numeric(input$cur_b_1_3), as.numeric(input$cur_b_1_4), as.numeric(input$cur_b_1_5), as.numeric(input$cur_a_2_2), as.numeric(input$cur_b_2_2), as.numeric(input$n_p), as.matrix(input$x_toxic_input_1_2), as.matrix(input$x_toxic_input_1_3), as.matrix(input$x_toxic_input_1_4), as.matrix(input$x_toxic_input_1_5), as.matrix(input$x_toxic_input_2_2), as.matrix(input$n_input_1_2), as.matrix(input$n_input_1_3), as.matrix(input$n_input_1_4), as.matrix(input$n_input_1_5), as.matrix(input$n_input_2_2), as.matrix(input$pess_input_1_2), as.matrix(input$pess_input_1_3), as.matrix(input$pess_input_1_4), as.matrix(input$pess_input_1_5), as.matrix(input$pess_input_2_2), as.matrix(input$threshold_input_1_2_non_informative), as.matrix(input$threshold_input_1_3_non_informative), as.matrix(input$threshold_input_1_4_non_informative), as.matrix(input$threshold_input_1_5_non_informative), as.matrix(input$threshold_input_2_2_non_informative), as.matrix(input$threshold_input_1_2_informative), as.matrix(input$threshold_input_1_3_informative), as.matrix(input$threshold_input_1_4_informative), as.matrix(input$threshold_input_1_5_informative), as.matrix(input$threshold_input_2_2_informative),as.numeric(input$stage_input), as.matrix(input$dlt_true_input_1_2), as.matrix(input$dlt_true_input_1_3), as.matrix(input$dlt_true_input_1_4), as.matrix(input$dlt_true_input_1_5), as.matrix(input$dlt_true_input_2_2), as.numeric(input$simulation_runs))
    }) 
  # Output the result
   output$result <- renderPrint({
      result()})
} #1
```
# Shiny App
```{r shiny_app, message=FALSE, warning=FALSE}
shinyApp(ui, server)
```
