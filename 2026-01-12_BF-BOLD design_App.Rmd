---
title: Backfilled Bayesian Ordered Lattice Design (BF-BOLD) for Phase I Clinical Trials
author: Gi-Ming Wang & Curtis Tatsuoka
date: 1/10/2026
output: html_document
runtime: shiny
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA)
```
# Preliminaries
```{r Preliminaries, message = FALSE, warning=FALSE}
library(ggplot2)
library(gridExtra) # Arrange the plots
library(ggbreak) # For axis break
library(dplyr)
library(ggpubr)
library(tidyverse)
library(broom)
library(readxl)
library(scales) # For ggplot segmented bar chart
library(MASS)
library(officer)
library(flextable)
library(tidyverse)
library(png)
library(Iso) # For isotonic regression biviso()
library(shiny) # For GUI (Graphic user interface)
library(shinyMatrix) # For matrix input of GUI (Graphic user interface)
```
# Functions
```{r Functions, message=FALSE, warning=FALSE}
my_function <- function(action, lattice, backfill_option, p_target, p_target_efficacy, ppat_selection, backfill_strategy, CPAT_efficacy_threshold_for_backfill, efficacy_trade_off, n_stop_total, n_stop_BOLD_1, n_stop_BOLD, prior_information, dlt_prior_input_1_2, dlt_prior_input_1_3, dlt_prior_input_1_4, dlt_prior_input_1_5, dlt_prior_input_2_2, cur_b_1_2, cur_b_1_3, cur_b_1_4, cur_b_1_5, cur_a_2_2, cur_b_2_2, n_p, n_input_MTD_1_2, n_input_MTD_1_3, n_input_MTD_1_4, n_input_MTD_1_5, n_input_MTD_2_2, n_input_Backfill_1_2, n_input_Backfill_1_3, n_input_Backfill_1_4, n_input_Backfill_1_5, n_input_Backfill_2_2, x_toxic_input_1_2, x_toxic_input_1_3, x_toxic_input_1_4, x_toxic_input_1_5, x_toxic_input_2_2,  x_efficacy_input_1_2, x_efficacy_input_1_3, x_efficacy_input_1_4, x_efficacy_input_1_5, x_efficacy_input_2_2, pess_input_1_2, pess_input_1_3, pess_input_1_4, pess_input_1_5, pess_input_2_2, threshold_input_1_2_non_informative, threshold_input_1_3_non_informative, threshold_input_1_4_non_informative, threshold_input_1_5_non_informative, threshold_input_2_2_non_informative, threshold_input_1_2_informative, threshold_input_1_3_informative, threshold_input_1_4_informative, threshold_input_1_5_informative, threshold_input_2_2_informative, stage, dlt_true_input_1_2, dlt_true_input_1_3, dlt_true_input_1_4, dlt_true_input_1_5, dlt_true_input_2_2, efficacy_true_input_1_2, efficacy_true_input_1_3, efficacy_true_input_1_4, efficacy_true_input_1_5, efficacy_true_input_2_2, simulation_runs)
 { #1
  # Specify backfill option
  if (backfill_option=="Yes")
   { #2
    backfill <- 1
   } else 
   { #2
    backfill <- 0
   } #2
  # Specify backfill strategy
  if (backfill_strategy=="Evenly backfilled from dose j-1 to dose 1 with fixed cohort (n = 3)")
   { #2
     backfill_choice <- 1
   } #2
  if (backfill_strategy=="Evenly backfilled from dose j-1 to dose 1 with random cohort (n = 1, 2 or 3)")
   { #2
     backfill_choice <- 5
   } #2
  if (backfill_strategy=="Backfilled at dose j-1 with fixed cohort (n = 3)")
   { #2
     backfill_choice <- 2
   } #2
  if (backfill_strategy=="Backfilled at dose j-1 with random cohort (n = 1, 2, or 3)")
   { #2
     backfill_choice <- 3
   } #2
  if (backfill_strategy=="Backfilled at dose j-1 with fixed cohort (n = 1)")
   { #2
     backfill_choice <- 4
   } #2
 # Specify the current dose level.
  if (lattice=="2x2") # 2x2 combination-drug trial
   { #2
    level_a <- 2
    level_b <- 2
    cur_a <- cur_a_2_2
    cur_b <- cur_b_2_2
   } else #2 Single-drug trial
   { #2
     level_a <- 1
     cur_a <- 1
     if (lattice=="1x2")
      { #3
       level_b <- 2
       cur_b <- cur_b_1_2
      } #3
     if (lattice=="1x3")
      { #3
       level_b <- 3
       cur_b <- cur_b_1_3
       } #3
     if (lattice=="1x4")
      { #3
       level_b <- 4
       cur_b <- cur_b_1_4
      } #3
     if (lattice=="1x5")
      { #3
        level_b <- 5
        cur_b <- cur_b_1_5
      } #3
    } #2
  # Specify prior mean of toxicity
  if (prior_information=="Non-informative")
   { #2
    dlt_prior <- matrix(p_target,nrow=level_a, ncol=level_b) # Prior mean is set to be the target rate for non-informative prior.
   } else #2
   { #2
    if (lattice=="1x2") {dlt_prior <- matrix(as.numeric(dlt_prior_input_1_2),level_a,level_b)}
    if (lattice=="1x3") {dlt_prior <- matrix(as.numeric(dlt_prior_input_1_3),level_a,level_b)}
    if (lattice=="1x4") {dlt_prior <- matrix(as.numeric(dlt_prior_input_1_4),level_a,level_b)}
    if (lattice=="1x5") {dlt_prior <- matrix(as.numeric(dlt_prior_input_1_5),level_a,level_b)}
    if (lattice=="2x2")
     { #3
      dlt_prior <- matrix(as.numeric(dlt_prior_input_2_2),level_a, level_b)
      dlt_prior[1,] <- matrix(as.numeric(dlt_prior_input_2_2[2,],level_a,level_b)) # For 2x2 lattice, the sequence of level a needs to be reversed.
      dlt_prior[2,] <- matrix(as.numeric(dlt_prior_input_2_2[1,],level_a,level_b))
     } #3
   } #2
  # Specify prior mean of activity
  if (backfill==1)
   { #2
     efficacy_prior <- matrix(p_target_efficacy, nrow=level_a, ncol=level_b) # Prior mean of activity is set to be the target activity (minimum acceptable toxicity rate).
   } #2
  # Specify accumulated number of DLTs.
  if (action=="Conducting")
   { #2
     if (lattice=="1x2") {BOLD_x_count_matrix <- matrix(as.numeric(x_toxic_input_1_2),level_a,level_b)}
     if (lattice=="1x3") {BOLD_x_count_matrix <- matrix(as.numeric(x_toxic_input_1_3),level_a,level_b)}
     if (lattice=="1x4") {BOLD_x_count_matrix <- matrix(as.numeric(x_toxic_input_1_4),level_a,level_b)}
     if (lattice=="1x5") {BOLD_x_count_matrix <- matrix(as.numeric(x_toxic_input_1_5),level_a,level_b)}
     if (lattice=="2x2")
       { #3
        BOLD_x_count_matrix <- matrix(as.numeric(x_toxic_input_2_2),level_a,level_b)
        BOLD_x_count_matrix[1,] <- matrix(as.numeric(x_toxic_input_2_2[2,],level_a,level_b)) # For 2x2 lattice, the sequence of level a needs to be updated
        BOLD_x_count_matrix[2,] <- matrix(as.numeric(x_toxic_input_2_2[1,],level_a,level_b))
       } #3
   } #2
  # Specify accumulated number of treated patients in MTD trial.
  if (action=="Conducting")
   { #2
    if (lattice=="1x2") {BOLD_n_count_matrix_MTD <- matrix(as.numeric(n_input_MTD_1_2),level_a,level_b)}
    if (lattice=="1x3") {BOLD_n_count_matrix_MTD <- matrix(as.numeric(n_input_MTD_1_3),level_a,level_b)}
    if (lattice=="1x4") {BOLD_n_count_matrix_MTD <- matrix(as.numeric(n_input_MTD_1_4),level_a,level_b)}
    if (lattice=="1x5") {BOLD_n_count_matrix_MTD <- matrix(as.numeric(n_input_MTD_1_5),level_a,level_b)}
    if (lattice=="2x2")
      { #3
       BOLD_n_count_matrix_MTD <- matrix(as.numeric(n_input_MTD_2_2),level_a,level_b)
       BOLD_n_count_matrix_MTD[1,] <- matrix(as.numeric(n_input_MTD_2_2[2,],level_a,level_b)) # For a 2x2 lattice, it is necessary to revise the sequence of level a.
       BOLD_n_count_matrix_MTD[2,] <- matrix(as.numeric(n_input_MTD_2_2[1,],level_a,level_b))
      } #3
   } #2
  # Specify accumulated number of treated patients in Backfill trial.
  if (backfill==1 & action=="Conducting")
   { #2
    if (lattice=="1x2") {BOLD_n_count_matrix_Backfill <- matrix(as.numeric(n_input_Backfill_1_2),level_a,level_b)}
    if (lattice=="1x3") {BOLD_n_count_matrix_Backfill <- matrix(as.numeric(n_input_Backfill_1_3),level_a,level_b)}
    if (lattice=="1x4") {BOLD_n_count_matrix_Backfill <- matrix(as.numeric(n_input_Backfill_1_4),level_a,level_b)}
    if (lattice=="1x5") {BOLD_n_count_matrix_Backfill <- matrix(as.numeric(n_input_Backfill_1_5),level_a,level_b)}
    if (lattice=="2x2")
      { #3
       BOLD_n_count_matrix_Backfill <- matrix(as.numeric(n_input_Backfill_2_2),level_a,level_b)
       BOLD_n_count_matrix_Backfill[1,] <- matrix(as.numeric(n_input_Backfill_2_2[2,],level_a,level_b)) # For a 2x2 lattice, it is necessary to revise the sequence of level a.
       BOLD_n_count_matrix_Backfill[2,] <- matrix(as.numeric(n_input_Backfill_2_2[1,],level_a,level_b))
      } #3
   } #2
  # Count the total number of treated patients (including MTD trial and possible backfill trial)
  if (action=="Conducting")
    { #2
      if (backfill==0)
        { #3
          BOLD_n_count_matrix_All <- BOLD_n_count_matrix_MTD
        } else #3
        { #3
          BOLD_n_count_matrix_All <- BOLD_n_count_matrix_MTD + BOLD_n_count_matrix_Backfill
        } #3
     } #2
  # Specify accumulated number of activity
  if (backfill==1 & action=="Conducting")
   { #2
     if (lattice=="1x2") {BOLD_efficacy_count_matrix <- matrix(as.numeric(x_efficacy_input_1_2),level_a,level_b)}
     if (lattice=="1x3") {BOLD_efficacy_count_matrix <- matrix(as.numeric(x_efficacy_input_1_3),level_a,level_b)}
     if (lattice=="1x4") {BOLD_efficacy_count_matrix <- matrix(as.numeric(x_efficacy_input_1_4),level_a,level_b)}
     if (lattice=="1x5") {BOLD_efficacy_count_matrix <- matrix(as.numeric(x_efficacy_input_1_5),level_a,level_b)}
     if (lattice=="2x2")
       { #3
        BOLD_efficacy_count_matrix <- matrix(as.numeric(x_efficacy_input_2_2),level_a,level_b)
        BOLD_efficacy_count_matrix[1,] <- matrix(as.numeric(x_efficacy_input_2_2[2,],level_a,level_b)) # For 2x2 lattice, the sequence of level a needs to be updated
        BOLD_efficacy_count_matrix_[2,] <- matrix(as.numeric(x_efficacy_input_2_2[1,],level_a,level_b))
       } #3
   } #2
  # Specify PESS (Prior estimated sample size).
  if (lattice=="1x2") {pess_matrix <- matrix(as.numeric(pess_input_1_2),level_a,level_b)}
  if (lattice=="1x3") {pess_matrix <- matrix(as.numeric(pess_input_1_3),level_a,level_b)}
  if (lattice=="1x4") {pess_matrix <- matrix(as.numeric(pess_input_1_4),level_a,level_b)}
  if (lattice=="1x5") {pess_matrix <- matrix(as.numeric(pess_input_1_5),level_a,level_b)}
  if (lattice=="2x2")
   { #2
    pess_matrix <- matrix(as.numeric(pess_input_2_2),level_a,level_b)
    pess_matrix[1,] <- matrix(as.numeric(pess_input_2_2[2,],level_a,level_b)) # For a 2x2 lattice, it is necessary to revise the sequence of level a.
    pess_matrix[2,] <- matrix(as.numeric(pess_input_2_2[1,],level_a,level_b))
   } #2
  # Specify the threshold for excessively toxic doses.
  if (prior_information=="Non-informative")
   { #2
     if (lattice=="1x2") {threshold_matrix <- matrix(as.numeric(threshold_input_1_2_non_informative),level_a,level_b)}
     if (lattice=="1x3") {threshold_matrix <- matrix(as.numeric(threshold_input_1_3_non_informative),level_a,level_b)}
     if (lattice=="1x4") {threshold_matrix <- matrix(as.numeric(threshold_input_1_4_non_informative),level_a,level_b)}
     if (lattice=="1x5") {threshold_matrix <- matrix(as.numeric(threshold_input_1_5_non_informative),level_a,level_b)}
     if (lattice=="2x2")
       { #3
        threshold_matrix <- matrix(as.numeric(threshold_input_2_2_non_informative),level_a,level_b)
        threshold_matrix[1,] <- matrix(as.numeric(threshold_input_2_2_non_informative[2,],level_a,level_b)) # For a 2x2 lattice, it is necessary to revise the sequence of level a.
        threshold_matrix[2,] <- matrix(as.numeric(threshold_input_2_2_non_informative[1,],level_a,level_b))
     } #3 
   } else #2 For informative prior
   { #2
     if (lattice=="1x2") {threshold_matrix <- matrix(as.numeric(threshold_input_1_2_informative),level_a,level_b)}
     if (lattice=="1x3") {threshold_matrix <- matrix(as.numeric(threshold_input_1_3_informative),level_a,level_b)}
     if (lattice=="1x4") {threshold_matrix <- matrix(as.numeric(threshold_input_1_4_informative),level_a,level_b)}
     if (lattice=="1x5") {threshold_matrix <- matrix(as.numeric(threshold_input_1_5_informative),level_a,level_b)}
     if (lattice=="2x2")
       { #3
        threshold_matrix <- matrix(as.numeric(threshold_input_2_2_informative),level_a,level_b)
        threshold_matrix[1,] <- matrix(as.numeric(threshold_input_2_2_informative[2,],level_a,level_b)) # For 2x2 lattice, the sequence of level a needs to be updated
        threshold_matrix[2,] <- matrix(as.numeric(threshold_input_2_2_informative[1,],level_a,level_b))
     } #3   
   } #2
  # Specify true DLT rates for simulation.
  if (action=="Simulation")
   { #2 
    if (lattice=="1x2") {dlt_true <-  matrix(as.numeric(dlt_true_input_1_2),level_a,level_b)}
    if (lattice=="1x3") {dlt_true <- matrix(as.numeric(dlt_true_input_1_3),level_a,level_b)}
    if (lattice=="1x4") {dlt_true <- matrix(as.numeric(dlt_true_input_1_4),level_a,level_b)}
    if (lattice=="1x5") {dlt_true <- matrix(as.numeric(dlt_true_input_1_5),level_a,level_b)}
    if (lattice=="2x2")
     { #3
      dlt_true <- matrix(as.numeric(dlt_true_input_2_2),level_a, level_b)
      dlt_true[1,] <- matrix(as.numeric(dlt_true_input_2_2[2,],level_a,level_b)) # For a 2x2 lattice, it is necessary to revise the sequence of level a.
      dlt_true[2,] <- matrix(as.numeric(dlt_true_input_2_2[1,],level_a,level_b))
     } #3
  } #2
 # Specify true activity rates for simulation.
  if (action=="Simulation" & backfill==1)
   { #2 
    if (lattice=="1x2") {efficacy_true <-  matrix(as.numeric(efficacy_true_input_1_2),level_a,level_b)}
    if (lattice=="1x3") {efficacy_true <- matrix(as.numeric(efficacy_true_input_1_3),level_a,level_b)}
    if (lattice=="1x4") {efficacy_true <- matrix(as.numeric(efficacy_true_input_1_4),level_a,level_b)}
    if (lattice=="1x5") {efficacy_true <- matrix(as.numeric(efficacy_true_input_1_5),level_a,level_b)}
    if (lattice=="2x2")
     { #3
      efficacy_true <- matrix(as.numeric(efficacy_true_input_2_2),level_a, level_b)
      efficacy_true[1,] <- matrix(as.numeric(efficacy_true_input_2_2[2,],level_a,level_b)) # For a 2x2 lattice, it is necessary to revise the sequence of level a.
      efficacy_true[2,] <- matrix(as.numeric(efficacy_true_input_2_2[1,],level_a,level_b))
     } #3
  } #2
 # Verify the coherence of the input data.
  check <- 0
  # Check prior means of DLT rates.
    ## Prior means must be positive and less than 1.
  if (all(dlt_prior>0 & dlt_prior<=1)==FALSE)
   { #2
    cat("Prior mean DLT rates must be beween 0 and 1. \n")
    check <- 1
   } #2
    ## prior means must be non-decreasing.
  if (level_a==1)
   { #2
     if (all(diff(dlt_prior[1,])>=0)==FALSE)
      { #3
        cat("Prior mean DLT rates must be non-decreasing. \n")
        check <- 1
      } #3
   } else #2
   { #2
     if (dlt_prior[1,1]>dlt_prior[1,2] |  dlt_prior[1,1]>dlt_prior[2,1] | dlt_prior[1,1]>dlt_prior[2,2] | dlt_prior[1,2]>dlt_prior[2,2] | dlt_prior[2,1]>dlt_prior[2,2])
     { #3
       cat("Prior mean DLT rates must be non-decreasing. \n")
       check <- 1
     } #3
   } #2
  # Check true DLT rates for simulation.
    ## True DLT rates must be positive.
  if (action=="Simulation")
   { #2
     if (all(dlt_true>0 & dlt_true<=1)==FALSE)
       { #3
         cat("True DLT rates cannot be negative or greater than 1. \n")
         check <- 1
       } #3
    ## True DLT rates must be non-decreasing.
     if (level_a==1)
       { #3
        if (all(diff(dlt_true[1,])>=0)==FALSE)
         { #4
          cat("True DLT rates must be non-decreasing. \n")
          check <- 1
         } #4
      } else #3
      { #3
        if (dlt_true[1,1]>dlt_true[1,2] |  dlt_true[1,1]>dlt_true[2,1] | dlt_true[1,1]>dlt_true[2,2] | dlt_true[1,2]>dlt_true[2,2] | dlt_true[2,1]>dlt_true[2,2])
          { #4
            cat("True DLT rates must be non-decreasing. \n")
            check <- 1
          } #4
       } #3
    } #2
 # Check true activity rates for simulation.
    ## True activity rates must be positive.
  if (action=="Simulation" & backfill==1)
   { #2
     if (all(efficacy_true>0 & efficacy_true<=1)==FALSE)
       { #3
         cat("True activity rates cannot be negative or greater than 1. \n")
         check <- 1
       } #3
    ## True activity rates must be non-decreasing.
    if (level_a==1)
      { #3
        if (all(diff(efficacy_true[1,])>=0)==FALSE)
          { #4
             cat("True activity rates must be non-decreasing. \n")
             check <- 1
          } #4
      } else #3
      { #3
        if (efficacy_true[1,1]>efficacy_true[1,2] |  efficacy_true[1,1]>efficacy_true[2,1] | efficacy_true[1,1]>efficacy_true[2,2] | efficacy_true[1,2]>efficacy_true[2,2] | efficacy_true[2,1]>efficacy_true[2,2])
          { #4
            cat("True activity rates must be non-decreasing. \n")
            check <- 1
          } #4
       } #3
   } #2
  # Check current dose level.
  ## The current dose level for conducting the trial cannot be higher than the highest dose.
  if (action=="Conducting")
   { #2
     if (cur_a>level_a | cur_b>level_b)
      { #3
       cat("Current dose cannot be higher than the highest dose.")
       check<-1
      } #3
  ## The current dose level must be greater than 0.
    if (cur_a<1 | cur_b<1)
      { #3
       cat("Current dose cannot be lower than the lowest dose.")
       check<-1
      } #3
   } #2
   # Check the accumulated number of treated patients in MTD trial.
    ## The accumulated n of the lowest dose in MTD trial cannot be 0 (i.e., trial has to start from the lowest dose)
    if (action=="Conducting")
     { #2
       if (BOLD_n_count_matrix_MTD[1,1]==0) 
         { #3
          cat("The sample size of the lowest dose in MTD trial cannot be 0 (i.e., trial has to start from the lowest dose). \n")
          check <- 1
         } #3
   ## Total number of treated patients in MTD trial is capped.
     if (sum(BOLD_n_count_matrix_MTD)>n_stop_total)
       { #3
        cat("Total sample size in MTD trial cannot be greater than the maximum N for MTD trial, \n")
        check <- 1
       } #3 
    } #2
  # Check the accumulated number of DLT's.
  ## Accumulated DLT's of each dose must not be greater than the accumulated n of that dose
   if (action=="Conducting")
    { #2
      if ((all(BOLD_x_count_matrix>=0) &                 all(BOLD_x_count_matrix<=BOLD_n_count_matrix_All))==FALSE)
       { #3
        cat("Accumulated DLTs of each dose level cannot be greater than its sample size. \n")
        check <- 1
       } #3
   ## Total sum of x cannot be greater than total n
     if (sum(BOLD_x_count_matrix)>sum(BOLD_n_count_matrix_All))
       { #3
        cat("Total DLTs cannot be greater than total N \n")
        check <- 1
       } #3 
    } #2
  # Check PESS.
   ## PESS of each dose must be between 0 and 12.
   if ((all(pess_matrix>0) & all(pess_matrix<=n_stop_BOLD))==FALSE)
       { #2
        cat("PESS of each dose must be 0<PESS<=12. \n")
        check <- 1
       } #2
  # Check toxicity thresholds.
   ## Threshold of each dose must be between 0 and 1.
   if ((all(threshold_matrix>0) & all(threshold_matrix<1))==FALSE)
       { #2
        cat("Toxicity threshold of each dose must be 0<threshold<1. \n")
        check <- 1
       } #2
  # Check stage(s).
   ## The stages of conducting a clinical trial utilizing a 2x2 lattice design must commence at 1 and progress incrementally by 1 to facilitate the selection of incomparable doses.
   if (action=="Conducting" & lattice=="2x2")
    { #2
     if ((sum(BOLD_n_count_matrix_MTD)==3 & stage!=1) | sum(BOLD_n_count_matrix_MTD)/n_p!=stage)
       { #3
        cat("For combination-drug trials, \n")
        cat("stage must commence at 1 and progress \n")
        cat("incrementally by 1 to facilitate \n")
        cat("the selection of incomparable doses. \n")
        check <- 1
       } #3
     } #2
  # Set up data structure.
  if (check==0)
   { # Check==0
     a <- list() # List of A levels, where each A level includes all the B levels. We assume the maximum dose level of both drugs (A an B) is 5
     a[[1]] <- data.frame(level_A=c("A1", "A1", "A1", "A1", "A1"), level_B=c("B1", "B2", "B3", "B4", "B5"))
     a[[2]] <- data.frame(level_A=c("A2", "A2", "A2", "A2", "A2"), level_B=c("B1", "B2", "B3", "B4", "B5"))
     a[[3]] <- data.frame(level_A=c("A3", "A3", "A3", "A3", "A3"), level_B=c("B1", "B2", "B3", "B4", "B5"))
     a[[4]] <- data.frame(level_A=c("A4", "A4", "A4", "A4", "A4"), level_B=c("B1", "B2", "B3", "B4", "B5"))
     a[[5]] <- data.frame(level_A=c("A5", "A5", "A5", "A5", "A5"), level_B=c("B1", "B2", "B3", "B4", "B5"))
  # Remove the unused levels of B.
  for (i in 1:level_a)
    {a[[i]]<-a[[i]][c(1:level_b),]}
  # Specify the parameters and statistics.
  for (i in 1:level_a)
   { #2
    for (j in 1:level_b)
     { #3
      a[[i]]$prior_alpha[j] <- dlt_prior[i,j]*pess_matrix[i,j]
      a[[i]]$prior_beta[j] <- pess_matrix[i,j]-a[[i]]$prior_alpha[j]
      if (backfill==1)
       { #4
        a[[i]]$prior_alpha_efficacy[j] <- efficacy_prior[i,j]*pess_matrix[i,j] 
        a[[i]]$prior_beta_efficacy[j] <- pess_matrix[i,j]-a[[i]]$prior_alpha_efficacy[j]
       } #4
     } #3
   } #2
  # Start the app (Conducting the trial or running simulations).
  if (action=="Conducting" | action=="Simulation") # Begin to run the app.
   { #2
    BOLD_mean_factor <- 100 # A large value as default.
    pava_on_cpat_global <- 0 # "1" means applying global PAVA on the CPAT for PPATA across the whole 2x2 lattice; "0" means applying local PAVA among neighboring doses of 2x2 lattice.
    pava_on_conjugate_global <- 1 # "1" means applying global PAVA on the conjugate mean across the whole 2x2 lattice; "0" means applying local PAVA among neighboring doses of 2x2 lattice.
    summary_BOLD_administered_count_matrix <- matrix(0,level_a,level_b) # The frequency of being administered for summary purpose.
    summary_BOLD_n_count_matrix_All <- matrix(0,level_a,level_b) # The frequency of treated patients in total.
    summary_BOLD_n_count_matrix_MTD <- matrix(0,level_a,level_b) # The frequency of treated patients in MTD trial only.
    summary_BOLD_n_count_matrix_Backfill <- matrix(0,level_a,level_b) # The frequency of treated patients in Backfill only.
    summary_BOLD_too_toxic_matrix <- matrix(0,level_a,level_b) # The frequency of current doses being overly toxic.
    summary_BOLD_mtd_count_matrix <- matrix(0,level_a,level_b) # The count of doses being identified as MTD.
    summary_BOLD_obd_count_matrix <- matrix(0,level_a,level_b) # The count of doses being identified as OBD.
    BOLD_n_count_total_vector <- vector() # The total number of treated patients for each simulation run.
    if (action=="Conducting")
     { #3
       runs <- 1 # Running for once.
     } else #3
     { #3
       runs <- simulation_runs # Running for iterations.
     } #3
    for (k in 1:runs) 
     { #3 # Loop for simulation runs (only once for conducting clinical trial)
      BOLD_mean_matrix <- matrix(NA, level_a, level_b) # Set up the matrix of posterior (conjugate) mean DLT rates.
      conjugate_prob_above <- matrix(NA, nrow=level_a, ncol=level_b) # CPAT, the conjugate probability of DLT rate being above target.
      prob_half_up_matrix_pava <- matrix(NA, nrow=level_a, ncol=level_b) # PPAT, the posterior probability of DLT rate being above target after PAVA is applied on CPAT.
      BOLD_mean_matrix_efficacy <- matrix(NA, nrow=level_a, ncol=level_b) # The matrix of posterior (conjugate) mean activity rates.
      BOLD_mean_matrix_efficacy_pava <- matrix(NA, nrow=level_a, ncol=level_b) # The matrix of posterior (conjugate) mean activity rates after PAVA.
       prob_half_up_matrix_final_previous <- matrix(0,level_a,level_b) # The default PPAT of the preceding stage for 2x2 design.
       prob_half_up_matrix_efficacy <- matrix(NA, nrow=level_a, ncol=level_b) # CPAT of efficacy
       BOLD_administered_count_matrix <- matrix(0,level_a,level_b)
       BOLD_too_toxic <- matrix(0,level_a,level_b) # Default matrix of overly toxic current doses.
       BOLD_not_toxic <- matrix(0,level_a,level_b) # Default matrix of none-toxic current doses.
       BOLD_too_toxic_trace <- matrix(0,level_a,level_b) # Default matrix of overly toxic doses (current doses only, not including any higher level doses).
       BOLD_mtd_contour_matrix <- matrix(0, nrow=level_a, ncol=level_b) # Indicatoe if a dose is identified as a MTD. 
       BOLD_obd_contour_matrix <- matrix(0, nrow=level_a, ncol=level_b) # Indicator if a dose is identified as a OBD.
       if (action=="Simulation") # The setting below is only for running simulations.
        { #4
         stage <- 0
         cur_a <- 1 # Initial dose level is the lowest dose.
         cur_b <- 1
         BOLD_x_count_matrix <- matrix(0,level_a,level_b)
         BOLD_n_count_matrix_MTD <- matrix(0,level_a,level_b)
         BOLD_n_count_matrix_Backfill <- matrix(0,level_a,level_b)
         BOLD_n_count_matrix_All <- matrix(0,level_a,level_b)
         BOLD_efficacy_count_matrix <- matrix(0,level_a,level_b)          } #4
      if (action=="Conducting") # The setting below is only for conducting a clinical trial.
       { #4
         if (lattice=="2x2" & stage==1)
          { #5
           prob_half_up_matrix_final_previous <<- matrix(0,level_a,level_b) # The default PPAT of the preceding stage for 2x2 design.
          } #5
       } #4
      repeat
       { #4 Loop for stages
         if (action=="Simulation")
          { #5
           stage <- stage + 1
           x_toxic <- rbinom(n=1, size=n_p, prob=dlt_true[cur_a,cur_b]) # Use Binomial distribution to generate DLTs of the current dose in MTD trial.
           BOLD_x_count_matrix[cur_a,cur_b] <- x_toxic + BOLD_x_count_matrix[cur_a,cur_b] # Add the observed number of toxic number to the total number of toxicity.
           BOLD_n_count_matrix_MTD[cur_a,cur_b]<- n_p + BOLD_n_count_matrix_MTD[cur_a,cur_b] # Add the number of observed patients to the number of patients in MTD trial.
           BOLD_n_count_matrix_All[cur_a,cur_b]<- n_p + BOLD_n_count_matrix_All[cur_a,cur_b] # Add the number of observed patients to the total number of patients in both MTD trial and Backfill trial.
           if (backfill==1)
            { #6
             x_efficacy <- rbinom(n=1, size=n_p, prob=efficacy_true[cur_a,cur_b]) # Use Binomial distribution to generate activities of the current dose in MTD trial.
             BOLD_efficacy_count_matrix[cur_a,cur_b] <- x_efficacy + BOLD_efficacy_count_matrix[cur_a,cur_b] # Add the observed number of activity number to the total number of activity.
            } #6
           BOLD_administered_count_matrix[cur_a, cur_b] <- BOLD_administered_count_matrix[cur_a, cur_b] + 1 # Record the frequency of being administered.
          } #5
       # Backfilling begins
        stop_backfill <- 0 # Default
        if (action=="Simulation" & backfill==1)
         { #5
           chosen_a_efficacy <- 1 # # Default highest chosen dose for backfilling of drug A.
           chosen_b_efficacy <- 0 # # Default highest chosen dose for backfilling of drug B.
           for (i in 1:level_a)
            { #6
              for (j in 1:level_b)
                { #7
                  prob_half_up_matrix_efficacy[i,j] <- 1-pbeta(p_target_efficacy, shape1=a[[i]]$prior_alpha_efficacy[j]+BOLD_efficacy_count_matrix[i,j], shape2=a[[i]]$prior_beta_efficacy[j]+BOLD_n_count_matrix_All[i,j]-BOLD_efficacy_count_matrix[i,j]) # This is to calculate CPAT which will be used to evaluate the dose selection for backfilling
                } #7
            } #6
        ## Using the following criteria for the availability of backfilling: (1) It has to be below the current dose of MTD trial; (2) Efficacy CPAT must be greater than 0.1; (3) If there are multiple dose candidates for BF, the highest dose will be chosen.
          if (level_a==1)
            { #6
             if (level_b==5)
              { #7
                loss_efficacy <- c(5,4,3,2,1) # Assign larger loss to lower dose levels and smaller loss to the higher dose levels in order to select the highest dose among the backfill candidate doses.
              } #7
            if (level_b==4)
              { #7
                loss_efficacy <- c(4,3,2,1) # Assign larger loss to lower dose levels and smaller loss to the higher dose levels in order to select the highest dose among the backfill candidate doses.
              } #7
           if (level_b==3)
              { #7
                loss_efficacy <- c(3,2,1) 
              } #7
          if (level_b==2)
              { #7
                loss_efficacy <- c(2,1) 
              } #7
            } #6
       # Exclusion rule #1 (Dose level control)
        if (level_a==1)
          { #6
           for (j in 1:level_b)
            { #7
              if (j>=cur_b) 
               { #8
                loss_efficacy[j] <- 100 # Assign a large value
               } #8
            } #7
          } #6
     # Exclusion rule #2 (Activity control)
        if (level_a==1)
         { #6
           for (j in 1:level_b)
             { #7
               if (prob_half_up_matrix_efficacy[1,j]<CPAT_efficacy_threshold_for_backfill)
                 { #8
                   for (jj in 1:j)
                     { #9
                      loss_efficacy[jj] <- 100 # Assign a large value
                     } #9
                 } #8
             } #7
           } #6
        if (level_a==1 & sum(loss_efficacy)<100*level_b) # At least one dose is qualified for backfilling.
           { #6
            xxx <- loss_efficacy  
            chosen_b_efficacy <- which(xxx==min(xxx)) # Select the highest dose, where there won't be be a tie.
           } #6
      # Stopping rule of Backfilling
      ## Rule : Total N (MTD trial only) reaches the ceiling
        if (level_a==1)
          { #6
            if (sum(BOLD_n_count_matrix_MTD) >= n_stop_total) # When total N (Not including backfilling) reaches max_N.
              { #7
               stop_backfill <- 1
              } #7
           } #6
          # Generate the number of efficacy and toxicity in Backfilling process 
          if (stop_backfill==0 & level_a==1)
            { #6
              backfill_dose_lowest <- 0 # Default lowest dose level to be backfilled
              backfill_dose_highest <- 0 # Default highest dose level to be backfilled
              if (backfill_choice==1 & chosen_b_efficacy>0) # If the chosen dose for backfill exists for evenly backfilling of cohort size 3
                { #7
                  if (cur_b==2) # Backfill 3 patients with dose 1
                   { #8
                    backfill_vector <- 3
                    backfill_dose_lowest <- 1 # The lowest dose level to be backfilled
                    backfill_dose_highest <- 1 # The highest dose level to be backfilled
                   } #8
                 if (cur_b==3) 
                   { #8
                     if (loss_efficacy[1]<100) # Randomly assign patients to dose 1 and 2
                       { #9
                         cohort_vector <- c(1,2) # Total number is 3
                         backfill_vector <- sample(cohort_vector, 2, replace = FALSE)
                         backfill_dose_lowest <- 1 # The lowest dose level to be backfilled
                         backfill_dose_highest <- 2 # The highest dose level to be backfilled
                       } #9  
                    if (loss_efficacy[1]==100) # Assign patients to dose 2
                       { #9
                        backfill_vector <- c(0,3)
                        backfill_dose_lowest <- 2 # The lowest dose level to be backfilled
                        backfill_dose_highest <- 2 # The highest dose level to be backfilled
                       } #9
                     } #8 
                  if (cur_b==4) 
                     { #8
                       if (loss_efficacy[1]<100) # Randomly assign patients to dose 1, 2 and 3
                        { #9
                         backfill_vector <- c(1,1,1)
                         backfill_dose_lowest <- 1 # The lowest dose level to be backfilled
                         backfill_dose_highest <- 3 # The highest dose level to be backfilled
                        } #9
                     if (loss_efficacy[1]==100 & loss_efficacy[2]<100) # Assign patients to doses 2 and 3
                        { #9
                         cohort_vector <- c(1,2) # Total number is 3
                         backfill_vector <- c(0, sample(cohort_vector, 2, replace = FALSE))
                         backfill_dose_lowest <- 2 # The lowest dose level to be backfilled
                         backfill_dose_highest <- 3 # The highest dose level to be backfilled
                        } #9
                     if (loss_efficacy[1]==100 & loss_efficacy[2]==100) # Assign patients to dose 3
                        { #9
                         backfill_vector <- c(0,0,3)
                         backfill_dose_lowest <- 3 # The lowest dose level to be backfilled
                         backfill_dose_highest <- 3 # The highest dose level to be backfilled
                        } #9
                     } #8
                   if (cur_b==5)
                     { #8
                      if (loss_efficacy[2]<100) # Randomly assign patients to dose 2, 3 and 4
                        { #9
                          backfill_vector <- c(0,1,1,1)
                          backfill_dose_lowest <- 2 # The lowest dose level to be backfilled
                          backfill_dose_highest <- 4 # The highest dose level to be backfilled
                        } #9
                      if (loss_efficacy[2]==100 & loss_efficacy[3]<100) # Assign patients to doses 3 and 4
                        { #9
                         cohort_vector <- c(1,2) # Total number is 3
                         backfill_vector <- c(0,0, sample(cohort_vector, 2, replace = FALSE))
                         backfill_dose_lowest <- 3 # The lowest dose level to be backfilled
                         backfill_dose_highest <- 4 # The highest dose level to be backfilled
                       } #9
                    if (loss_efficacy[2]==100 & loss_efficacy[3]==100) # Assign patients to dose 4
                       { #9
                         backfill_vector <- c(0,0,0,3)
                         backfill_dose_lowest <- 4 # The lowest dose level to be backfilled
                         backfill_dose_highest <- 4 # The highest dose level to be backfilled
                       } #9
                    } #8
                 } #7
               if (backfill_choice==2 | backfill_choice==3 | backfill_choice==4) # Designate the anti-cover dose for backfilling
                 { #7
                   if (chosen_b_efficacy>0 & cur_b>1) # If the chosen dose for backfill exists and cur_b is not the lowest dose.
                     { #8
                      backfill_vector <- rep(0,cur_b-1) # Default
                      backfill_dose_lowest <- cur_b-1 # The lowest dose level to be backfilled
                      backfill_dose_highest <- cur_b-1 # The highest dose level to be backfilled
                      if (backfill_choice==2)
                       { #9
                         backfill_vector[cur_b-1] <- 3 # Set a cohort size of 3 for backfilling at the anti-cover dose.
                       } #9
                     if (backfill_choice==3)
                       { #9
                         backfill_vector[cur_b-1] <- sample(c(1,2,3),1) # Randomly choose a cohort size among 1, 2, and 3 for backfill.
                        } #9
                     if (backfill_choice==4)
                        { #9
                          backfill_vector[cur_b-1] <- 1 # Set a cohort size of 1 for backfill.
                         } #9
                      } #8 
                   } #7
               if (backfill_choice==5 & chosen_b_efficacy>0) # If the chosen dose for backfill exists for evenly backfilling of cohort size <= 3
                  { #7 
                    cohort_size <- sample(c(1,2,3),1, replace=FALSE) # Randomly determine the cohort size from a total cohort size of 3
                    if (cohort_size==3)
                      { #8
                        if (cur_b==2) # Backfill patients with dose 1
                         { #9
                          backfill_vector <- 3
                          backfill_dose_lowest <- 1 # The lowest dose level to be backfilled
                          backfill_dose_highest <- 1 # The highest dose level to be backfilled
                         } #9
                        if (cur_b==3) 
                         { #9
                          if (loss_efficacy[1]<100) # Randomly assign patients to dose 1 and 2
                            { #10
                             cohort_vector <- c(1,2) # Total number is 3
                             backfill_vector <- sample(cohort_vector, 2, replace = FALSE)
                             backfill_dose_lowest <- 1 # The lowest dose level to be backfilled
                             backfill_dose_highest <- 2 # The highest dose level to be backfilled
                           } #10       
                         if (loss_efficacy[1]==100) # Assign patients to dose 2
                           { #10
                             backfill_vector <- c(0,3)
                             backfill_dose_lowest <- 2 # The lowest dose level to be backfilled
                             backfill_dose_highest <- 2 # The highest dose level to be backfilled
                           } #10
                       } #9
                    if (cur_b==4) 
                       { #9
                         if (loss_efficacy[1]<100) # Randomly assign patients to dose 1, 2 and 3
                           { #10
                             backfill_vector <- c(1,1,1) # Total number is 3
                             backfill_dose_lowest <- 1 # The lowest dose level to be backfilled
                             backfill_dose_highest <- 3 # The highest dose level to be backfilled
                           } #10
                        if (loss_efficacy[1]==100 & loss_efficacy[2]<100) # Assign patients to doses 2 and 3
                           { #10
                             cohort_vector <- c(1,2) # Total number is 3
                             backfill_vector <- c(0, sample(cohort_vector, 2, replace = FALSE))
                             backfill_dose_lowest <- 2 # The lowest dose level to be backfilled
                             backfill_dose_highest <- 3 # The highest dose level to be backfilled
                           } #10
                       if (loss_efficacy[1]==100 & loss_efficacy[2]==100) # Assign patients to dose 3
                           { #10
                             backfill_vector <- c(0,0,3)
                             backfill_dose_lowest <- 3 # The lowest dose level to be backfilled
                             backfill_dose_highest <- 3 # The highest dose level to be backfilled
                           } #10
                         } #9
                      if (cur_b==5) 
                         { #9
                          if (loss_efficacy[2]<100) # Randomly assign patients to dose 2, 3 and 4
                            { #10
                              backfill_vector <- c(0,1,1,1) # Total number is 3
                              backfill_dose_lowest <- 2 # The lowest dose level to be backfilled
                              backfill_dose_highest <- 4 # The highest dose level to be backfilled
                            } #10
                        if (loss_efficacy[2]==100 & loss_efficacy[3]<100) # Assign patients to doses 3 and 4
                            { #10
                              cohort_vector <- c(1,2) # Total number is 3
                              backfill_vector <- c(0,0, sample(cohort_vector, 2, replace = FALSE))
                              backfill_dose_lowest <- 3 # The lowest dose level to be backfilled
                              backfill_dose_highest <- 4 # The highest dose level to be backfilled
                            } #10
                        if (loss_efficacy[2]==100 & loss_efficacy[3]==100) # Assign patients to dose 4
                            { #10
                             backfill_vector <- c(0,0,0,3)
                             backfill_dose_lowest <- 4 # The lowest dose level to be backfilled
                             backfill_dose_highest <- 4 # The highest dose level to be backfilled
                            } #10
                          } #9
                       } #8
                    if (cohort_size==2)
                       { #8   
                         if (cur_b==2) # Backfill 2 patients with dose 1
                           { #9
                              backfill_vector <- 2
                              backfill_dose_lowest <- 1 # The lowest dose level to be backfilled
                              backfill_dose_highest <- 1 # The highest dose level to be backfilled
                           } #9
                       if (cur_b==3) 
                           { #9
                             if (loss_efficacy[1]<100) # Randomly assign patients to dose 1 and 2
                              { #10
                                backfill_vector <- c(1,1)
                                backfill_dose_lowest <- 1 # The lowest dose level to be backfilled
                                backfill_dose_highest <- 2 # The highest dose level to be backfilled
                              } #10
                           if (loss_efficacy[1]==100) # Assign patients to dose 2
                              { #10
                               backfill_vector <- c(0,2)
                               backfill_dose_lowest <- 2 # The lowest dose level to be backfilled
                               backfill_dose_highest <- 2 # The highest dose level to be backfilled
                              } #10
                           } #9
                        if (cur_b==4) 
                           { #9
                            if (loss_efficacy[2]<100) # Assign patients to doses 2 and 3
                             { #10
                               backfill_vector <- c(0,1,1)
                               backfill_dose_lowest <- 2 # The lowest dose level to be backfilled
                               backfill_dose_highest <- 3 # The highest dose level to be backfilled
                             } #10
                         if (loss_efficacy[2]==100) # Assign patients to dose 3
                            { #10
                              backfill_vector <- c(0,0,2)
                              backfill_dose_lowest <- 3 # The lowest dose level to be backfilled
                              backfill_dose_highest <- 3 # The highest dose level to be backfilled
                            } #10
                          } #9
                       if (cur_b==5) 
                          { #9
                           if (loss_efficacy[3]<100) # Assign patients to doses 3 and 4
                             { #10
                               backfill_vector <- c(0,0,1,1)
                               backfill_dose_lowest <- 3 # The lowest dose level to be backfilled
                               backfill_dose_highest <- 4 # The highest dose level to be backfilled
                             } #10
                         if (loss_efficacy[3]==100) # Assign patients to dose 4
                             { #10
                               backfill_vector <- c(0,0,0,2)
                               backfill_dose_lowest <- 4 # The lowest dose level to be backfilled
                               backfill_dose_highest <- 4 # The highest dose level to be backfilled
                             } #10
                           } #9
                         } #8
                      if (cohort_size==1)
                        { #8   
                          if (cur_b>1) # If the current dose is not the lowest dose.
                           { #9
                             backfill_vector <- rep(0,cur_b-1) # Default
                             backfill_vector[cur_b-1] <- 1
                             backfill_dose_lowest <- cur_b-1 # The lowest dose level to be backfilled
                             backfill_dose_highest <- cur_b-1 # The highest dose level to be backfilled
                           } #9
                         } #8
                     } #7
                 if (backfill_dose_lowest>0 & backfill_dose_highest>0)
                   { #7
                     for (j in backfill_dose_lowest:backfill_dose_highest)
                       { #8 
                         x_efficacy <- rbinom(n=1, size=backfill_vector[j], prob=efficacy_true[1,j]) # Use Binomial distribution to generate the number of efficacy
                         x_toxicity <- rbinom(n=1, size=backfill_vector[j], prob=dlt_true[1,j]) # Use Binomial distribution to generate the number of DLTs.
                         BOLD_efficacy_count_matrix[1,j] <- BOLD_efficacy_count_matrix[1,j] + x_efficacy
                         BOLD_x_count_matrix[1,j] <- BOLD_x_count_matrix[1,j] + x_toxicity
                         BOLD_n_count_matrix_All[1,j] <- BOLD_n_count_matrix_All[1,j] + backfill_vector[j]                    
                         BOLD_n_count_matrix_Backfill[1,j] <- BOLD_n_count_matrix_Backfill[1,j] + backfill_vector[j]
                     } #8
                  } #7  
              } #6
          # Update conjugated means of efficacy
            for (i in 1:level_a)
             { #6
               for (j in 1:level_b)
                { #7
                 BOLD_mean_matrix_efficacy[i,j] <- (a[[i]]$prior_alpha_efficacy[j]+BOLD_efficacy_count_matrix[i,j])/(a[[i]]$prior_alpha_efficacy[j]+a[[i]]$prior_beta_efficacy[j]+BOLD_n_count_matrix_All[i,j]) # This is exactly the conjugate mean activity.
                } #7 
             } #6
         # Calculate posterior mean efficacy after PAVA
            for (i in 1:level_a)
              { #6
                BOLD_mean_matrix_efficacy_pava[i,] <- pava(BOLD_mean_matrix_efficacy[i,], BOLD_n_count_matrix_All[i,])
              } #6
           } #5 Backfilling ends
         # Perform dose selection for MTD trial
         # Calculate CPAT
        for (i in 1:level_a)
          { #5
            for (j in 1:level_b)
              { #6
                conjugate_prob_above[i,j] <- 1-pbeta(p_target, shape1=a[[i]]$prior_alpha[j]+BOLD_x_count_matrix[i,j], shape2=a[[i]]$prior_beta[j]+BOLD_n_count_matrix_All[i,j]-BOLD_x_count_matrix[i,j]) # CPAT
              } #6
          } #5
      # Calculate PPAT by applying PAVA on CPAT
      prob_half_up_matrix_pava <- conjugate_prob_above # Default matrix of PPAT.
      if (level_a==1)
        { #5
          if (cur_b>2)
            { #6
              for (j in 1:(cur_b-2))
                { #7
                   prob_half_up_matrix_pava[cur_a,j]<-0 # Set a very small value for PAVA.
                } #7
            } #6
          if (cur_b<level_b-1)
            { #6
              for (j in (cur_b+2):level_b)
                { #7
                 prob_half_up_matrix_pava[cur_a,j]<-100 # Set a very large value for PAVA
                } #7
            } #6
       BOLD_weight <- vector() # The weights for PAVA.
       for (j in 1:level_b)
         { #6
          BOLD_weight[j] <- BOLD_n_count_matrix_All[level_a,j] # The weights are the accumulated number of treated patients.
          } #6
      prob_half_up_matrix_pava[level_a,] <- pava(y=prob_half_up_matrix_pava[level_a,],w=BOLD_weight, decreasing=FALSE) # Applying PAVA with weights.
      } else #5 For 2x2
      { #5
        if (pava_on_cpat_global==1) # Applying global PAVA.
         { #6
          prob_half_up_matrix_pava <- biviso(prob_half_up_matrix_pava, weight_matrix) # Weight matrix needs to be specified global PAVA is applied..
         } #6
      if (pava_on_cpat_global==0) # Local PAVA
        # We don't use biviso() for dose selection on 2x2. When the cover dose value with 0 weight is larger than the current dose, it wrongly becomes the current dose value, yet pava() correctly keeps the upper dose value as it is.
       { #6
         weight_column_cur_b <- vector() # The vector of weights for the column of the current dose.
         for (i in 1:level_a)
          { #7
            weight_column_cur_b[i] <- BOLD_n_count_matrix_All[i,cur_b]
          } #7
         weight_row_cur_a <- vector() # The vector of weights for the row of the current dose.
         for (j in 1:level_b)
          { #7
            weight_row_cur_a[j] <- BOLD_n_count_matrix_All[cur_a,j]
          } #7
         for (pava_times in 1:100) # Apply PAVA on the row and column of the current doses by iterations.
         { #7
           prob_half_up_matrix_pava[cur_a,] <- pava(prob_half_up_matrix_pava[cur_a,], weight_row_cur_a)
           prob_half_up_matrix_pava[,cur_b] <- pava(prob_half_up_matrix_pava[,cur_b], weight_column_cur_b)
         } # 7
        } #6
      } #5
  prob_half_up_matrix_final <- round(prob_half_up_matrix_pava,3) # PPAT after adjustment with PAVA is rounded to 3 digits.
  if (level_a==2 & level_b==2) # 2x2 design
       { #5 
         if (stage>1 & cur_a==1 & cur_b==2)
           { #6
             prob_half_up_matrix_final[2,1] <- prob_half_up_matrix_final_previous[2,1] # Use the PPAT from the previous PPAT matrix for the diagonal dose of the current dose.
           } #6
        if (stage>1 & cur_a==2 & cur_b==1)
           { #6
             prob_half_up_matrix_final[1,2] <- prob_half_up_matrix_final_previous[1,2]
           } #6
        if (cur_a==1 & cur_b==1)
          { #6
           prob_half_up_matrix_final[2,2] <- 100 # A larger value indicates that the non-neighboring dose will not be the candidate for dose selection.
          } #6
       if (cur_a==2 & cur_b==2)
          { #6
           prob_half_up_matrix_final[1,1] <- 100 # A larger value indicates that the non-neighboring dose will not be the candidate for dose selection.
          } #6
      } #5
   # Overdose control
    excluded_matrix <- matrix(0,level_a,level_b) # Default matrix of excluded doses from trial.
    for (i in 1:level_a)
     { #5
      for (j in 1:level_b)
       { #6
        if (conjugate_prob_above[i,j]>=threshold_matrix[i,j]) # Using CPAT for overdose control.
         { #7
           for (ii in i:level_a)
             { #8
               for (jj in j:level_b)
                 { #9
                   BOLD_too_toxic[ii,jj] <- 1
                   excluded_matrix[ii,jj] <- 1
                 } #9
               } #8
            } #7
        } #6
     } #5
   if (action=="Simulation" & conjugate_prob_above[cur_a,cur_b]>=threshold_matrix[cur_a,cur_b]) # Trace the current doses which are overly toxic.
    { #5 
     for (i in cur_a:level_a) # All the doses above the current dose (including the current dose) will be considered overly toxic if the currenet dose is overly toxic.
      { #6
       for (j in cur_b:level_b)
        { #7
         BOLD_too_toxic_trace[i,j] <- BOLD_too_toxic_trace[i,j]+1
        } #7
      } #6
     } #5
   # Dose selection based on loss function.
    for (i in 1:level_a)
      { #5
       for (j in 1:level_b)
        { #6 
          if (is.na(prob_half_up_matrix_final[i,j])==FALSE & excluded_matrix[i,j]!=1 & abs(i-cur_a+j-cur_b)<2) # The dose selection is among the neighborhood doses. In this context, the incomparable dose is also considered a "neighborhood" dose, despite not being adjusted by PAVA in the same manner as the other doses prior to this.
            { #7
              a[[i]]$prob_loss[j] <- abs(prob_half_up_matrix_final[i,j]-ppat_selection) 
            } else #7
            { #7
              a[[i]]$prob_loss[j] <- 100 # Assigning a large value of loss function.
            } #7
         } #6
    } #5
   selected_b <- vector() # Candidate of B levels for each dose level of A.
   for (i in 1:level_a)
     { #5
         xxx <- a[[i]]$prob_loss
         z <- which(xxx==min(xxx)) # There can be a tie.
         if (prob_half_up_matrix_final[i,z[1]]<ppat_selection) # The PPAT of the tie is less than 0.5.
           { #6
             selected_b[i] <- z[length(z)] # Select the highest dose if the tie is less than 0.5.
           } else #6
           { #6
             selected_b[i] <- z[1] # Select the lowest dose if the tie is greater than 0.5.
           } #6
     } #5
    candidates <- vector()
    for (i in 1:level_a)
      { #5
        candidates[i] <- a[[i]]$prob_loss[selected_b[i]]
      } #5
    xxx <- candidates
    zz <- which(xxx==min(xxx)) # There can be a tie.
    if (length(zz)==1)
      { #5
         chosen_a <- zz[1]
      } #5
     if (length(zz)==2) # For 2x2 lattice, there can only be maximum 2 doses being tied.
       { #5
        if (prob_half_up_matrix_final[zz[1],selected_b[zz[1]]]==prob_half_up_matrix_final[zz[2],selected_b[zz[2]]])
         { #6
          if (zz[1]<zz[2] & selected_b[zz[1]]>selected_b[zz[2]]) # Incomparable doses.
           { #7
             if (runif(1,0,1)<0.5) # Coin flip
              { #8
               chosen_a <- zz[1]
              } else #8
              { #8
                chosen_a <- zz[2]
              } #8
           } else #7 Comparable doses.
           { #7
            if (prob_half_up_matrix_final[zz[1],selected_b[zz[1]]]<ppat_selection)
             { #8
               chosen_a <- zz[2] # Select the highest dose if the tie is less than 0.5.
             } else #8
             { #8
               chosen_a <- zz[1] # Select the lowest dose if the tie is greater than 0.5.
             } #8
           } #7
         } else #6 One is less than 0.5 and the other is greater than 0.5.
         { #6
           if (prob_half_up_matrix_final[zz[1],selected_b[zz[1]]]<ppat_selection)
             { #7
               chosen_a <- zz[2] # Select the highest dose.
             } else #7
             { #7
               chosen_a <- zz[1] # Select the lowest dose.
             } #7
         } #6
      } #5
    chosen_b <- selected_b[chosen_a] # Select the final dose level of B.
    if (excluded_matrix[chosen_a,chosen_b]==1) # Check if the chosen dose has been excluded from the trial.
      { #5
        chosen_a <- cur_a # Stay at the current dose.
        chosen_b <- cur_b
      } #5
  # Stopping rules
  # Stopping rule #0: For conducing a clinical trial and not running a simulation.
   stopping_0 <- 0
   if (action=="Conducting")
    { #5    
      stopping_0 <- 1
    } #5
  # Stopping rule #1: The lowest dose is overly toxic.
   stopping <- 0
   stopping_reason <<- 0
  if (BOLD_too_toxic[1,1]==1)
    { #5    
      stopping <- 1
      stopping_reason <<- 1
    } #5
  # Stopping rule #2: Total number of treated patients in MTD trial reaches the ceiling.
   if (sum(BOLD_n_count_matrix_MTD)>=n_stop_total)
    { #5
      stopping <- 1
      stopping_reason <<- 2
    } #5
  # Stopping rule #3: The number of treated patients at the current dose (including both MTD trial and Backfilled) reaches the maximum and the decision is to stay at the current dose.
  if (cur_a==1 & cur_b==1)
   { #5
    n_stop_BOLD_new <- n_stop_BOLD_1
   } else #5
   { #5
     n_stop_BOLD_new <- n_stop_BOLD
   } #5
  if (BOLD_n_count_matrix_All[cur_a,cur_b] >= n_stop_BOLD_new & chosen_a==cur_a & chosen_b==cur_b & excluded_matrix[cur_a,cur_b]==0)
    { #5
       stopping <- 1
       stopping_reason <<- 3
       excluded_matrix[i,j] <- 2 # The dose will not be excluded from the final MTD selection at the end.
    } #5
   # Stopping rule #4 No dose is available to be selected for the next stage.
   test_available <- 0
   for (i in 1:level_a)
     { #5
      for (j in 1:level_b)
       { #6
         if (excluded_matrix[i,j]==0)
           { #7
             test_available <- 1
           } #7
       } #6
     } #5
   if (test_available==0)
    { #5
      stopping <- 1
      stopping_reason <<- 4
    } #5
   if (action=="Conducting")
    { #5
      prob_half_up_matrix_final_previous <<- prob_half_up_matrix_final # Reserve for the next stage on 2x2 design.
    } else #5
    { #5
      prob_half_up_matrix_final_previous <- prob_half_up_matrix_final # Reserve for the next stage on 2x2 design.
    } #5
   if (stopping_0==1 | stopping==1)
       { #5
        break
       } else #5
       { #5
         # Update current dose
          cur_a <- chosen_a # Reset the current dose using the chosen dose.
          cur_b <- chosen_b
       } #5
     } #4 Loop end for stages
    # MTD identification
    if (stopping==1) # Identify MTD only if any criterion of general stopping rules is met.
    { #4
    # Calculate the conjugate mean DLT rates.
     for (i in 1:level_a)
      { #5
        for (j in 1:level_b)
          { #6
           BOLD_mean_matrix[i,j] <- (a[[i]]$prior_alpha[j]+BOLD_x_count_matrix[i,j])/(a[[i]]$prior_alpha[j]+a[[i]]$prior_beta[j]+BOLD_n_count_matrix_All[i,j]) 
          } #6
      } #5
    # Apply PAVA on conjugate means.
    BOLD_mean_pava <- BOLD_mean_matrix # Default matrix.
    if (level_a==1) # For single-drug trial.
     { #5
       BOLD_weight <- vector() # The weights for PAVA.
       for (j in 1:level_b)
         { #6
          BOLD_weight[j] <- BOLD_n_count_matrix_All[level_a,j]
         } #6
       BOLD_mean_pava[1,] <- round(pava(BOLD_mean_pava[1,],BOLD_weight),3) # Rounding is needed, for the tiny difference between two values after PAVA should be ignored. The two values which are very close to each other after PAVA should be considered equal.
    } else #5 For combined-drug trials.
    { #5
    if (pava_on_conjugate_global==1) # Apply global PAVA using biviso().
     { #6
       weight_matrix <- matrix(NA, nrow=level_a, ncol=level_b)
       for (i in 1:2) # Only applied for 2x2 lattice.
         { #7
          weight_matrix[i,] <- BOLD_n_count_matrix_All[i,]+pess_matrix[i,] # To avoid zero weight for biviso().
         } #7
    BOLD_mean_pava <- round(biviso(BOLD_mean_pava, weight_matrix),3)
     } #6
    if (pava_on_conjugate_global==0) # Applying local PAVA on neighboring doses. 
    { #6
     # Apply PAVA on the column of the current dose.
     weight_column_cur_b <- vector()
     for (i in 1:level_a)
      { #7
       weight_column_cur_b[i] <- BOLD_n_count_matrix_All[i,cur_b]
      } #7
    # Apply PAVA on the row of the current dose.
    weight_row_cur_a <- vector()
    for (j in 1:level_b)
     { #7
      weight_row_cur_a[j] <- BOLD_n_count_matrix_All[cur_a,j]
     } #7
    for (pava_times in 1:100)
     { #7
      BOLD_mean_pava[cur_a,] <- round(pava(BOLD_mean_pava[cur_a,], weight_row_cur_a),3)
      BOLD_mean_pava[,cur_b] <- round(pava(BOLD_mean_pava[,cur_b], weight_column_cur_b),3)
     } #7
   if (stage>1 & level_a==2 & level_b==2)
     { #7
        if (cur_a==1 & cur_b==2)
           { #8
             BOLD_mean_pava[2,1] <- BOLD_mean_pava_previous[2,1] # Use the posterior mean from the previous matrix for the diagonal dose of the current dose instead of using its conjugate mean.
           } #8
        if (cur_a==2 & cur_b==1)
           { #8
             BOLD_mean_pava[1,2] <- BOLD_mean_pava_previous[1,2]
           } #8
      } #7
     BOLD_mean_pava_previous <- BOLD_mean_pava
    } #6
  } #5
  # Exclude the non-candidates of MTD.
  for (i in 1:level_a)
   { #5
    for (j in 1:level_b)
     { #6
       if (abs(i-cur_a+j-cur_b)>=2 | BOLD_n_count_matrix_All[i,j]==0 | excluded_matrix[i,j]==1 | BOLD_mean_pava[i,j]>(1+BOLD_mean_factor)*p_target) # Exclude the dose which is neither neighboring dose nor incomparable dose, without trial data, having been eliminated from MTD candidates, or whose posterior mean after PAVA is greater than the (1+BOLD_mean_factor)*p_target, which is the acceptable upper limit.
        { #7
          BOLD_mean_pava[i,j] <- 100
        } #7
     } #6
  } #5
   # MTD identificationi: Select the dose(s) across the whole lattice whose posterior mean after PAVA is (are) nearest to the target rate.
    BOLD_mtd_contour_matrix_candidates <- matrix(0, nrow=level_a, ncol=level_b) # Indicate if a dose is identified as a MTD candidate.
   if (BOLD_too_toxic[1,1]==0) # We identify the MTD only when the lowest dose is not too toxic.
   { #5
     selected_b <- vector() # Candidate of B levels for each dose level of A.
     for (i in 1:level_a)
      { #6
        t <- abs(BOLD_mean_pava[i,]-p_target)
        candidate_index <- which(t==min(t)) # There can be ties among those values nearest to the target rate.
       if (BOLD_mean_pava[i,candidate_index[1]] < p_target)
         { #7
           if (BOLD_mean_pava[i,candidate_index[length(candidate_index)]] < p_target) # If the lower tie is less than target and the higher tie is also less than target, we identify the higher dose.
            { #8
             selected_b[i] <- candidate_index[length(candidate_index)] # Choose the highest dose level among the ties
            } else #8 If the lower tie is less than target and the higher tie is greater than target, then we identify the lower dose.
            { #8
             selected_b[i] <- candidate_index[1] # Choose the lowest dose level among the ties
            } #8
     } else #7 If the lower tie is greater than the target
     { #7
       selected_b[i] <- candidate_index[1] # Choose the lowest dose level among the ties
     } #7
  } #6
  candidates <- vector()
  for (i in 1:level_a)
   { #6
   candidates[i] <- BOLD_mean_pava[i,selected_b[i]]
   } #6
  tt <- abs(candidates-p_target)
  candidate_MTD_a <- which(tt==min(tt)) # Select the final dose level of A from the candidates. There can be more than one result if there is a tie.
  candidate_MTD_b <- selected_b[candidate_MTD_a] # Select the final dose level of B.
  BOLD_mtd_contour_matrix_candidates[candidate_MTD_a, candidate_MTD_b] <- 1
 } #5
  # Identify the final unique MTD.
  if (BOLD_too_toxic[1,1]==1 | sum(BOLD_mtd_contour_matrix_candidates)==0) # Check if there is no MTD identification. 
 { #5
  BOLD_final_MTD_a <- NA
  BOLD_final_MTD_b <- NA
 } else #5
 { #5
  if (sum(BOLD_mtd_contour_matrix_candidates)==1) # If there is only one MTD
   { #6
    for (i in 1:level_a)
    { #7
      for (j in 1:level_b)
       { #8
        if (BOLD_mtd_contour_matrix_candidates[i,j]==1)
         { #9
          BOLD_final_MTD_a <- i
          BOLD_final_MTD_b <- j
         } #9
      } #8
    } #7
  } #6
  if (sum(BOLD_mtd_contour_matrix_candidates)>1) # If there is a tie.
   { #6
    if (candidate_MTD_a[1]==1 & candidate_MTD_b[1]==2 & candidate_MTD_a[2]==2 & candidate_MTD_b[2]==1) # Check if the tie occurs between the incomparable doses (for 2x2 only).
    { #7
      if (BOLD_n_count_matrix_All[1,2]==BOLD_n_count_matrix_All[2,1]) # Check if the incomparable doses have the same number of treated patients.
        { #8
         if (runif(1,0,1)<0.5) # Flip a coin.
          { #9
           BOLD_final_MTD_a <- 1
           BOLD_final_MTD_b <- 2
          } else #9
          { #9
            BOLD_final_MTD_a <- 2
            BOLD_final_MTD_b <- 1
          } #9
        } else #8 We will identify the one with more treated patient between the incomparable doses.
        { #8
         number_n <- rep(0, level_a)
         for (i in 1:level_a)
           { #9
             for (j in 1:level_b)
              { #10
               if (BOLD_mtd_contour_matrix_candidates[i,j]==1)
                 { #11
                  number_n[i] <- BOLD_n_count_matrix_All[i,j]
                 } #11
              } #10
           } #9
        BOLD_final_MTD_a <- which.max(number_n)
        for (j in 1:level_b)
         { #9
           if (BOLD_mtd_contour_matrix_candidates[BOLD_final_MTD_a,j]==1)
             { #10
                BOLD_final_MTD_b <- j
             } #10
         } #9
      } #8
   } else #7 The tie is among the comparable doses.
   { #7
     if (BOLD_mean_pava[candidate_MTD_a[1],candidate_MTD_b[1]]>p_target)
      { #8
        BOLD_final_MTD_a <- candidate_MTD_a[1]
        BOLD_final_MTD_b <- candidate_MTD_b[1]
      } else #8
      { #8
        BOLD_final_MTD_a <- candidate_MTD_a[2]
        BOLD_final_MTD_b <- candidate_MTD_b[2]
      } #8
    } #7
   } #6
  BOLD_mtd_contour_matrix[BOLD_final_MTD_a,BOLD_final_MTD_b] <- 1
  } #5
  BOLD_final_MTD_pseudo <- NA
  if (is.na(BOLD_final_MTD_b)==TRUE) # Check if there is no MTD identification.
   { #5
    if (BOLD_too_toxic[1,1]==1)
     { #6
      BOLD_final_MTD_pseudo <- "Lower pseudo dose" # Lower pseudo dose is identified.
     } #6
    if (BOLD_not_toxic[level_a,level_b]==1)
     { #6
      BOLD_final_MTD_pseudo <- "Upper pseudo dose" # Upper pseudo dose is identified.
     } #6
    if (action=="Simulation")
     { #6
      if (dlt_true[level_a,level_b]<=p_target) # For simulations, if true DLT rate is less than or equal to the target rate, the highest dose will be identified as the MTD.
       { #7
         BOLD_mtd_contour_matrix[level_a,level_b] <- 1
       } #7
     } #6
   } #5
  } #4
  # OBD identification
  BOLD_final_OBD_pseudo <- NA
  if (action=="Conducting")
   { #4
    # Update conjugated means of efficacy
    for (i in 1:level_a)
      { #5
        for (j in 1:level_b)
          { #6
            BOLD_mean_matrix_efficacy[i,j] <- (a[[i]]$prior_alpha_efficacy[j]+BOLD_efficacy_count_matrix[i,j])/(a[[i]]$prior_alpha_efficacy[j]+a[[i]]$prior_beta_efficacy[j]+BOLD_n_count_matrix_All[i,j]) # This is exactly the conjugate mean activity.
           } #6 
       } #5
     for (i in 1:level_a)
       { #5
         BOLD_mean_matrix_efficacy_pava[i,] <- pava(BOLD_mean_matrix_efficacy[i,], BOLD_n_count_matrix_All[i,])
       } #5
    } #4
  if (stopping==1 & backfill==1) # Identify OBD only if any criterion of general stopping rules is met and backfilling was applied.
    { #4
      if (sum(BOLD_mtd_contour_matrix)>0) # There is a MTD identification
       { #5
         threshold_obd <- BOLD_mean_matrix_efficacy_pava[BOLD_final_MTD_a, BOLD_final_MTD_b]*(1-efficacy_trade_off)  # Set the trade-off threshold from classified MTD if its pava-adjusted posterior mean efficacy rate is greater than the target efficacy rate.
       } #5
    for (i in 1:level_a)
      { #5
        for (j in 1:level_b) 
         { #6 
           if (BOLD_mean_matrix_efficacy_pava[i,j]<threshold_obd | (i-BOLD_final_MTD_a+j-BOLD_final_MTD_b>0)) # Exclude the doses whose PAVA-adjusted posterior mean efficacy mean is either less than the trade-off threshold, or the dose is higher than the classified MTD (i.e. the incomparable dose in 2x2 lattice is also included as the candidate).
            { #7 
               BOLD_mean_matrix_efficacy_pava[i,j] <- 100
            } #7
          } #6
       } #5
    if (sum(BOLD_mean_matrix_efficacy_pava)<level_a*level_b*100) # At least one dose is qualified to be the optimal dose 
       { #5
         selected_b <- vector() # Candidate of B levels for each dose level of A
         target <- threshold_obd # Not the target efficacy rate but the threshold for optimal dose
         for (i in 1:level_a)
          { #6
            t <- abs(BOLD_mean_matrix_efficacy_pava[i,]-target)
            candidate_index <- which(t==min(t)) # There can be ties among those values closest to the target rate
            if (BOLD_mean_matrix_efficacy_pava[i,candidate_index[1]] < target) # This actually will not happen, for the dose with mean less than the target (i.e., trade-off threshold) has already been excluded.
              { #7
                if (BOLD_mean_matrix_efficacy_pava[i,candidate_index[length(candidate_index)]] < target) # We assume that there are maximum 2 doses being tied. If the lower tie is less than target and the higher tie is also less than target, then we identify the higher dose.
                  { #8
                   selected_b[i] <- candidate_index[length(candidate_index)] # Choose the highest dose level among the ties
                  } else #8 If the lower tie is less than target and the higher tie is greater than target, then we identify the lower dose.
                  { #8
                    selected_b[i] <- candidate_index[1] # Choose the lowest dose level among the ties
                  } #8
               } else #7 If the lower tie is greater than the target
               { #7
                selected_b[i] <- candidate_index[1] # Choose the lowest dose level among the ties
               } #7 
            } #6      
        candidates <- vector()
        for (i in 1:level_a)
          { #6
            candidates[i] <- BOLD_mean_matrix_efficacy_pava[i,selected_b[i]]
          } #6
        tt <- abs(candidates-target)
        final_OBD_a <- which(tt==min(tt)) # Select the final dose level of A from the candidates. There can be more than one result if there is a tie.
       if (length(final_OBD_a)>1) # There is a tie.
         { #6
           final_OBD_a <- 1 # Choose the lower level of A
         } #6
       final_OBD_b <- selected_b[final_OBD_a] # Select the final dose level of B for final_MTD_a to be the initial state
       BOLD_obd_contour_matrix[final_OBD_a, final_OBD_b] <- 1
    } else #5 If no dose is qualified to be the optimal dose (i.e., none of the doses is effective while there is a classified MTD), then set the optimal dose to be the same as the classified MTD.
    { #5
      final_OBD_a <- BOLD_final_MTD_a
      final_OBD_b <- BOLD_final_MTD_b
      BOLD_obd_contour_matrix[final_OBD_a, final_OBD_b] <- 1
    } #5
   } #4 
  # Summarize the statistics up to the kth simulation run
   summary_BOLD_too_toxic_matrix <- summary_BOLD_too_toxic_matrix + BOLD_too_toxic_trace # Matrix of total numbers of overly toxic doses up to the kth simulation run.
   summary_BOLD_administered_count_matrix <- summary_BOLD_administered_count_matrix + BOLD_administered_count_matrix # Matrix of total numbers of doses being administered up to the kth simulation run.
   BOLD_n_count_total_vector[k] <- sum(BOLD_n_count_matrix_All) # Vector of total number of treated patients per trial up to the kth simulation run.
   summary_BOLD_n_count_matrix_All <- summary_BOLD_n_count_matrix_All + BOLD_n_count_matrix_All # Matrix of total numbers of patients up to the kth simulation run.
   summary_BOLD_n_count_matrix_MTD <- summary_BOLD_n_count_matrix_MTD + BOLD_n_count_matrix_MTD # Matrix of total numbers of patients in MTD trial up to the kth simulation run.
   summary_BOLD_n_count_matrix_Backfill <- summary_BOLD_n_count_matrix_Backfill + BOLD_n_count_matrix_Backfill # Matrix of total numbers of patients in Backfill trial up to the kth simulation run.
   summary_BOLD_mtd_count_matrix <- summary_BOLD_mtd_count_matrix + BOLD_mtd_contour_matrix # Matrix of total frequencies of MTD identifications up to the kth simulation run.
   summary_BOLD_obd_count_matrix <- summary_BOLD_obd_count_matrix + BOLD_obd_contour_matrix # Matrix of total frequencies of OBD identifications up to the kth simulation run.
  } #3 Iteration end for simulation runs or conducting only one trial.
  # Print trial output or simulation result.
  if (action=="Conducting") 
   { #3
    cat("\n Number of total treated patients :\n")
     if (lattice=="1x2")  {cat(BOLD_n_count_matrix_All[,c(1:2)],"\n")}
     if (lattice=="1x3") {cat(BOLD_n_count_matrix_All[,c(1:3)],"\n")}
     if (lattice=="1x4") {cat(BOLD_n_count_matrix_All[,c(1:4)],"\n")}
     if (lattice=="1x5") {cat(BOLD_n_count_matrix_All[,c(1:5)],"\n")}
     if (lattice=="2x2")
      { #4
       cat("A2 (B1 B2) : ", BOLD_n_count_matrix_All[2,],"\n")
       cat("A1 (B1 B2) : ", BOLD_n_count_matrix_All[1,],"\n")
      } #4
    cat("\n Number of treated patients in MTD trial :\n")
     if (lattice=="1x2") {cat(BOLD_n_count_matrix_MTD[,c(1:2)],"\n")}
     if (lattice=="1x3") {cat(BOLD_n_count_matrix_MTD[,c(1:3)],"\n")}
     if (lattice=="1x4") {cat(BOLD_n_count_matrix_MTD[,c(1:4)],"\n")}
     if (lattice=="1x5") {cat(BOLD_n_count_matrix_MTD[,c(1:5)],"\n")}
     if (lattice=="2x2")
      { #4
       cat("A2 (B1 B2) : ", BOLD_n_count_matrix_MTD[2,],"\n")
       cat("A1 (B1 B2) : ", BOLD_n_count_matrix_MTD[1,],"\n")
      } #4
    cat("\n Number of treated patients in Backfill trial :\n")
     if (lattice=="1x2") {cat(BOLD_n_count_matrix_Backfill[,c(1:2)],"\n")}
     if (lattice=="1x3") {cat(BOLD_n_count_matrix_Backfill[,c(1:3)],"\n")}
     if (lattice=="1x4") {cat(BOLD_n_count_matrix_Backfill[,c(1:4)],"\n")}
     if (lattice=="1x5") {cat(BOLD_n_count_matrix_Backfill[,c(1:5)],"\n")}
     if (lattice=="2x2")
      { #4
       cat("A2 (B1 B2) : ", BOLD_n_count_matrix_Backfill[2,],"\n")
       cat("A1 (B1 B2) : ", BOLD_n_count_matrix_Backfill[1,],"\n")
      } #4
   cat("\n Number of DLTs :","\n")
     if (lattice=="1x2") {cat(BOLD_x_count_matrix[,c(1:2)],"\n")}
     if (lattice=="1x3") {cat(BOLD_x_count_matrix[,c(1:3)],"\n")}
     if (lattice=="1x4") {cat(BOLD_x_count_matrix[,c(1:4)],"\n")}
     if (lattice=="1x5") {cat(BOLD_x_count_matrix[,c(1:5)],"\n")}
     if (lattice=="2x2")
       { #4
        cat("A2 (B1 B2) : ", BOLD_x_count_matrix[2,],"\n")
        cat("A1 (B1 B2) : ", BOLD_x_count_matrix[1,],"\n")
       } #4
   cat("\n Number of activities :","\n")
     if (lattice=="1x2") {cat(BOLD_efficacy_count_matrix[,c(1:2)],"\n")}
     if (lattice=="1x3") {cat(BOLD_efficacy_count_matrix[,c(1:3)],"\n")}
     if (lattice=="1x4") {cat(BOLD_efficacy_count_matrix[,c(1:4)],"\n")}
     if (lattice=="1x5") {cat(BOLD_efficacy_count_matrix[,c(1:5)],"\n")}
     if (lattice=="2x2")
       { #4
        cat("A2 (B1 B2) : ", BOLD_efficacy_count_matrix[2,],"\n")
        cat("A1 (B1 B2) : ", BOLD_efficacy_count_matrix[1,],"\n")
       } #4
    if (stopping==0 | stopping==1)  
     { #4
      # Print PPATs
      for (i in 1:level_a)
       { #5
        for (j in 1:level_b)
         { #6
          if (prob_half_up_matrix_final[i,j]==0 | prob_half_up_matrix_final[i,j]>1)
           { #7
            prob_half_up_matrix_final[i,j] <- NA
           } #7
         } #6
       } #5
      cat("\n Posterior probabilities of DLT rates being above \n")
      cat("target rate (PPATs), where NA means non-neighborhood dose:","\n")
      if (lattice=="1x2")   {cat(prob_half_up_matrix_final[,c(1:2)],"\n")}
      if (lattice=="1x3") {cat(prob_half_up_matrix_final[,c(1:3)],"\n")}
      if (lattice=="1x4") {cat(prob_half_up_matrix_final[,c(1:4)],"\n")}
      if (lattice=="1x5") {cat(prob_half_up_matrix_final[,c(1:5)],"\n")}
      if (lattice=="2x2")
        { #5
          cat("A2B1 A2B2 : ", prob_half_up_matrix_final[2,],"\n")
          cat("A1B1 A1B2 : ", prob_half_up_matrix_final[1,],"\n")
        } #5
      # Print indicators of overly toxic doses
      cat("\n Whether the dose is overly toxic (0:no; 1:yes): \n")
      if (level_a==1)
       { #5
        cat(BOLD_too_toxic,"\n")
       } else #5
       { #5
        cat("A2B1 A2B2 : ", BOLD_too_toxic[2,],"\n")
        cat("A1B1 A1B2 : ", BOLD_too_toxic[1,],"\n")
       } #5
    } #4
  # Print the dose selection.
    if (stopping==0)
     { #4
      cat("\n Next dose selection : ")
       if (level_a==1)
         { #5
          cat("Level ", chosen_b, "\n")
         } else #5
         { #5
           cat("(A,B) = (",chosen_a,",", chosen_b,") \n")
         } #5
      } #4
    if (stopping==1) # We identify the MTD while conducting a clinical trial only when the stopping rule is met.
     { #4
      # Print the reason for the trial to be halted.
       if (stopping_reason==1)
        { #5
         cat("\n The trial was halted due to the \n")
         cat("excessive toxicity of the lowest dose.\n")
        } #5
       if (stopping_reason==2)
        { #5
         cat("\n The trial was halted as the total number \n")
         cat("of patients in MTD trial treated reached its limit.\n")
        } #5
       if (stopping_reason==3)
        { #5
         cat("\n The trial was halted upon reaching the maximum  \n")
         cat("number of total patients per dose and the decision \n")
         cat("is to maintain the current dose. \n")
        } #5
       if (stopping_reason==4)
        { #5
         cat("\n The trial was halted due to the \n")
         cat("unavailability of a selectable dose.  \n")
        } #5
       # Print the posterior mean DLT rates
       for (i in 1:level_a)
        { #5
         for (j in 1:level_b)
          { #6
           if (BOLD_mean_pava[i,j]==100)
            { #7
             BOLD_mean_pava[i,j] <- NA
            } #7
          } #6
        } #5
      cat("\n The posterior mean DLT rates (NA means not a MTD candidate):","\n")
      if (lattice=="1x2") {cat(BOLD_mean_pava[,c(1:2)],"\n")}
      if (lattice=="1x3") {cat(BOLD_mean_pava[,c(1:3)],"\n")}
      if (lattice=="1x4") {cat(BOLD_mean_pava[,c(1:4)],"\n")}
      if (lattice=="1x5") {cat(BOLD_mean_pava[,c(1:5)],"\n")}
      if (lattice=="2x2")
        { #5
          cat("A2", BOLD_mean_pava[2,],"\n")
          cat("A1", BOLD_mean_pava[1,],"\n")
        } #5
      # Print MTD identification.
      cat("\n MTD identification : ")
      if (is.na(BOLD_final_MTD_a)==FALSE)
         { #5
           if (level_a==1)
            { #6
             cat("Level ", BOLD_final_MTD_b,"\n")
            } else #6
            { #6
             cat("(A,B) = (",BOLD_final_MTD_a,",", BOLD_final_MTD_b,") \n")
            } #6
        } else #5 No MTD identification
        { #5
         cat(BOLD_final_MTD_pseudo,"\n")
        } #5
    } else #4
    { #4
      cat("\n The trial for MTD identification is still ongoing.")
    } #4
   # Print the posterior mean activity rates
   if (stopping==1) # We identify the OBD while conducting a clinical trial only when the stopping rule is met.
     { #4    
       for (i in 1:level_a)
        { #5
         for (j in 1:level_b)
          { #6
           if (BOLD_mean_matrix_efficacy_pava[i,j]==100)
            { #7
             BOLD_mean_matrix_efficacy_pava[i,j] <- NA
            } #7
          } #6
        } #5
      BOLD_mean_matrix_efficacy_pava <- round(BOLD_mean_matrix_efficacy_pava,3)
      cat("\n The posterior mean activity rates (NA means not a OBD candidate):","\n")
      if (lattice=="1x2") {cat(BOLD_mean_matrix_efficacy_pava[,c(1:2)],"\n")}
      if (lattice=="1x3") {cat(BOLD_mean_matrix_efficacy_pava[,c(1:3)],"\n")}
      if (lattice=="1x4") {cat(BOLD_mean_matrix_efficacy_pava[,c(1:4)],"\n")}
      if (lattice=="1x5") {cat(BOLD_mean_matrix_efficacy_pava[,c(1:5)],"\n")}
      if (lattice=="2x2")
        { #5
          cat("A2", BOLD_mean_matrix_efficacy_pava[2,],"\n")
          cat("A1", BOLD_mean_matrix_efficacy_pava[1,],"\n")
        } #5
      # Print OBD identification.
      cat("\n OBD identification : ")
      if (is.na(final_OBD_a)==FALSE)
         { #5
           if (level_a==1)
            { #6
             cat("Level ", final_OBD_b,"\n")
            } else #6
            { #6
             cat("(A,B) = (",final_OBD_a,",", final_OBD_b,") \n")
            } #6
         } else #5 No OBD identification
         { #5
           cat(BOLD_final_OBD_pseudo,"\n")
         } #5
      } else #4
      { #4
        cat("\n The trial for OBD identification is still ongoing.")
      } #4
   } #3       
 if (action=="Simulation")
   { #3
    # Print the average frequencies of administered doses.
     # cat("\n Average frequencies of administered doses: \n")
     # if (level_a==1)
     #   { #4
     #     cat(round(summary_BOLD_administered_count_matrix/k,2),"\n")
     #    } else #4
     #    { #4
     #     cat("A2B1 A2B2 : ", round(summary_BOLD_administered_count_matrix[2,]/k,2),"\n")
     #     cat("A1B1 A1B2 : ", round(summary_BOLD_administered_count_matrix[1,]/k,2),"\n")
     #    } #4
    # Print the percentages of MTD identification.
    cat("\n Percentages of MTD identification : \n")
    if (level_a==1)
      { #4
        cat(round(summary_BOLD_mtd_count_matrix/k,2),"\n")
      } else #4
      { #4
       cat("A2B1 A2B2 : ", round(summary_BOLD_mtd_count_matrix[2,]/k,2),"\n")
    cat("A1B1 A1B2 : ", round(summary_BOLD_mtd_count_matrix[1,]/k,2),"\n")
      } #4
   # Print the percentages of OBD identification.
    cat("\n Percentages of OBD identification : \n")
    if (level_a==1)
      { #4
        cat(round(summary_BOLD_obd_count_matrix/k,2),"\n")
      } else #4
      { #4
       cat("A2B1 A2B2 : ", round(summary_BOLD_obd_count_matrix[2,]/k,2),"\n")
    cat("A1B1 A1B2 : ", round(summary_BOLD_obd_count_matrix[1,]/k,2),"\n")
      } #4
   # Print the average number of total treated patients.
   cat("\n Average number of total treated patients : \n")
   cat(round(sum(summary_BOLD_n_count_matrix_All, na.rm=TRUE)/k,2),"\n")
    # Print the standard deviation of the number of treated patients.
    # cat("\n SD of the number of total treated patients : \n")
    # cat(round(sd(BOLD_n_count_total_vector, na.rm=TRUE),2),"\n")
    # Print the average number of treated patients in MTD trial.
    cat("\n Average number of treated patients in MTD trial : \n")
    cat(round(sum(summary_BOLD_n_count_matrix_MTD, na.rm=TRUE)/k,2),"\n")
    # Print the average number of treated patients in Backfill trial.
    cat("\n Average number of treated patients in Backfill trial : \n")
    cat(round(sum(summary_BOLD_n_count_matrix_Backfill, na.rm=TRUE)/k,2),"\n")
   # Print the probabilities of being overly toxic.
    cat("\n Probabilities of the doses being overly toxic: \n")
    if (level_a==1)
       { #4
         cat(round(summary_BOLD_too_toxic_matrix/k,2),"\n")
       } else #4
       { #4
         cat("A2B1 A2B2 : ", round(summary_BOLD_too_toxic_matrix[2,]/k,2),"\n")
         cat("A1B1 A1B2 : ", round(summary_BOLD_too_toxic_matrix[1,]/k,2),"\n")
        } #4       
    } #3
  } #2 End of starting App
 } # End of Check==0
} #1
```
# Setting for input
```{r settings, message=FALSE, warning=FALSE}
backfill_list <- c("Yes", "No") # Option of backfilling
# backfill_layer_gap_list <- c(0,1,2)
backfill_strategy_list <- c("Evenly backfilled from dose j-1 to dose 1 with fixed cohort (n = 3)", "Evenly backfilled from dose j-1 to dose 1 with random cohort (n = 1, 2 or 3)", "Backfilled at dose j-1 with fixed cohort (n = 3)", "Backfilled at dose j-1 with random cohort (n = 1, 2, or 3)", "Backfilled at dose j-1 with fixed cohort (n = 1)")
action_list <- c("Conducting", "Simulation") # Either conducting a clinical trial or running a simulation
action_list_backfill <- c("Simulation", "Conducting") # Backfilling is only for running a simulation in this app.
# choice <- c("1x2", "1x3", "1x4", "1x5", "2x2") # Choice of dose matrix
choice <- c("1x2", "1x3", "1x4", "1x5") # Choice of dose matrix
# target <- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3) # Possible target rate of DLT.
dose_level_a1_b2 <- c(1,2) # For the input of the dose level of the current dose for single-drug trial of 1x2 lattice.
dose_level_a1_b3 <- c(1,2,3) # For the input of the dose level of the current dose for single-drug trial of 1x3 lattice.
dose_level_a1_b4 <- c(1,2,3,4) # For the input of the dose level of the current dose for single-drug trial of 1x4 lattice.
dose_level_a1_b5 <- c(1,2,3,4,5) # For the input of the dose level of the current dose for single-drug trial of 1x5 lattice.
dose_level_a2_b2_a <- c(1,2) # For the input of the dose level A of the current dose for combined-drug trial.
dose_level_a2_b2_b <- c(1,2) # For the input of the dose level B of the current dose for combined-drug trial.
treated_patients <- c(1,2,3,4,5) # Cohort size for each stage of trial.
observed_dlt <- c(0,1,2,3) # Possible observed number of DLT's.
n_stop_BOLD <- c(6,7,8,9,10,11,12,13,14,15) # Maximum number of treated patients per dose.
n_stop_total <- c(21,24,27,30,33,36,39) # Maximum total number of treated patients in MTD trial.
prior_information_list <- c("Non-informative", "Informative") # Whether prior information is informative or non-informative
stage_list <- c(1,2,3,4,5,6,7,8,9,10) # The stage number with maximum 10 stges.
BOLD_mean_factor_list <- c(0.4,100)
simulation_runs_list <- c(100, 500, 1000, 2000, 5000, 10000)
```
# Shiny user interface
```{r user_interface, message=FALSE, warning=FALSE}
ui <- bslib::page_sidebar(
  titlePanel("Bayesian Ordered Lattice Design for Phase I Clinical Trials"),
  helpText(
      "This application was developed by Gi-Ming Wang and Curtis Tatsuoka to assist with dose selection and maximum tolerated dose (MTD) identification, with an option for backfilling."
    ),
  sidebar = bslib::sidebar(
  width=650, # The width of the sidebar at the left hand side.
  selectInput("action", label="Do you want to conduct a clinical trial (select 'Conducting') or run a simualtion (select 'Simulation')?", selected = "Simulation", action_list), # "selected" means that it will be automatically selected if the user does not make selection. The user can choose either to conduct a clinical trial or run a simulation.
  selectInput("backfill_option", label="Will backfilling be applied in the BOLD design?", selected = "Yes", backfill_list), # Choose the option for backfilling.
    # conditionalPanel(
  #    condition = c("input.backfill_option == 'Yes'"),
  # selectInput("action", label="The backfilling feature is exclusively intended for simulations within this app.", selected = "Simulation", action_list_backfill)), 
  selectInput("lattice", label="What's the lattice of dose levels? (Default lattice is 1x5)", selected = "1x5", choice), # Choose the drug lattice.
  sliderInput("p_target", label="What is the target DLT rate? (Default value is 0.25)", min=0.1, max=0.3, value=0.25, step = 0.01),
  conditionalPanel(
      condition = c("input.backfill_option == 'Yes'"), sliderInput("p_target_efficacy", label="What is the minimum acceptable activity rate? (Default value is 0.3)", min=0.1, max=0.35, value=0.3, step = 0.01)),
  sliderInput("ppat_selection", label="What is the PPAT threshold parameter? (Default value is 0.5)", min=0.45, max=0.55, value=0.5, step = 0.01),
  # conditionalPanel(
  #   condition = c("input.backfill_option == 'Yes'"), selectInput("backfill_layer_gap", label="What is number of layers the true optimal dose is lower than the true MTD?", selected = 1, backfill_layer_gap_list)), # Specify the backfill layer gap.
  conditionalPanel(
      condition = c("input.backfill_option == 'Yes' & input.action == 'Simulation'"),
      selectInput("backfill_strategy", label="What is your preferred backfill strategy when the currently administered dose is level j? (Default: Backfilled at dose j-1 with random cohort (n = 1, 2, or 3))", selected = "Backfilled at dose j-1 with random cohort (n = 1, 2, or 3)", backfill_strategy_list)), # Specify the backfill strategy.
  conditionalPanel(
      condition = c("input.backfill_option == 'Yes'"), sliderInput("CPAT_efficacy_threshold_for_backfill", label="What is the CPAT activity threshold for a dose to qualify as a backfilling candidate? (Default value is 0.1)", min=0.05, max=0.2, value=0.1, step=0.01)), # Specify the CPAT activity threshold for a dose to qualify as a backfilling candidate.
  conditionalPanel(
      condition = c("input.backfill_option == 'Yes'"), sliderInput("efficacy_trade_off", label="What is the trade-off rate from the classified MTD for the identification of Optimal Backfill Dose (Default value is 10%)", min=0.05, max=0.2, value=0.1, step=0.05)), # Specify the trade-off rate for OBD identification.
  sliderInput("n_p", "What is the number of treated patients per stage of trial? (Default value is 3)", min=1, max=10, value=3, step = 1),
  sliderInput("n_stop_BOLD_1", label="What is the maximum number of treated patients at the lowest dose for early stop? (Default value is 15)", min=1, max=30, value=15, step=1),
  sliderInput("n_stop_BOLD", label="What is the maximum number of treated patients at other doses for early stop? (Default value is 12)", min=1, max=30, value=12, step=1),
  sliderInput("n_stop_total", label="What is the maximum nubmer of total treated patients in MTD trial (Not including those treated at backfilled dose levels) ? (Default value is 30)", min=10, max=100, value=30, step=1),
  # Input prior means for trials with informative priors
   selectInput("prior_information", label="What is the prior information of toxicity (Non-informative or informative)?", selected = "Non-informative", prior_information_list), # The default is non-informative prior.
   conditionalPanel(
      condition = c("input.lattice == '1x2' & input.prior_information=='Informative'"),
matrixInput(
  "dlt_prior_input_1_2",
  label="Please input the prior mean DLT rates (Default values are 0.2 and 0.4 for dose 1 and 2):",
  value = matrix(c(0.2, 0.4), 1, 2, byrow=TRUE, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = c("input.lattice == '1x3' & input.prior_information=='Informative'"),
matrixInput(
  "dlt_prior_input_1_3",
  label="Please input the prior mean DLT rates (Default values are 0.2, 0.3 and 0.4 for dose 1, 2 and 3):",
  value = matrix(c(0.2,0.3,0.4), 1, 3, byrow=TRUE, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = c("input.lattice == '1x4' & input.prior_information=='Informative'"),
matrixInput(
  "dlt_prior_input_1_4",
  label="Please input the prior mean DLT rates (Default values are 0.1, 0.2, 0.3 and 0.4 for dose 1, 2, 3 and 4):",
  value = matrix(c(0.1,0.2,0.3,0.4), 1, 4, byrow=TRUE, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = c("input.lattice == '1x5' & input.prior_information=='Informative'"),
matrixInput(
  "dlt_prior_input_1_5",
  label="Please input the prior mean DLT rates (Default values are 0.1, 0.2, 0.3, 0.4 and 0.5 for dose 1, 2, 3, 4 and 5)",
  value = matrix(c(0.1,0.2,0.3,0.4,0.5), 1, 5, byrow=TRUE, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = c("input.lattice == '2x2' & input.prior_information=='Informative'"),
matrixInput(
  "dlt_prior_input_2_2",
  label="Please input the prior mean DLT rates (Default values are 0.1, 0.2, 0.2 and 0.3 for A1B1, A1B2, A2B1 and A2B2)",
  value = matrix(c(0.2, 0.3, 0.1, 0.2), 2, 2, byrow=TRUE, dimnames = list(c("A2", "A1"), c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
 # Input PESS :
  conditionalPanel(
      condition = "input.lattice == '1x2'",
matrixInput(
  "pess_input_1_2",
  label="Please provide the prior estimated sample sizes (PESS), defined as the sum of alpha and beta for the prior Beta distribution of DLT rate, with the default value set at 3 :",
  value = matrix(3, 1, 2, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x3'",
matrixInput(
  "pess_input_1_3",
  label="Please provide the prior estimated sample sizes (PESS), defined as the sum of alpha and beta for the prior Beta distribution of DLT rate, with the default value set at 3 :",
  value = matrix(3, 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x4'",
matrixInput(
  "pess_input_1_4",
  label="Please provide the prior estimated sample sizes (PESS), defined as the sum of alpha and beta for the prior Beta distribution of DLT rate, with the default value set at 3 :",
  value = matrix(3, 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x5'",
matrixInput(
  "pess_input_1_5",
  label="Please provide the prior estimated sample sizes (PESS), defined as the sum of alpha and beta for the prior Beta distribution of DLT rate, with the default value set at 3 :",
  value = matrix(3, 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '2x2'",
matrixInput(
  "pess_input_2_2",
  label="Please provide the prior estimated sample sizes (PESS), defined as the sum of alpha and beta for the prior Beta distribution of DLT rate, with the default value set at 3 :",
  value = matrix(3, 2, 2, dimnames = list(c("A2", "A1"), c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  # Input toxicity threshold.
  ## For non-informative prior.
  conditionalPanel(
      condition = "input.lattice == '1x2' & input.prior_information=='Non-informative'",
matrixInput(
  "threshold_input_1_2_non_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95), 1, 2, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x3' & input.prior_information=='Non-informative'",
matrixInput(
  "threshold_input_1_3_non_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95), 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x4' & input.prior_information=='Non-informative'",
matrixInput(
  "threshold_input_1_4_non_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95,0.95), 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
   conditionalPanel(
      condition = "input.lattice == '1x5' & input.prior_information=='Non-informative'",
matrixInput(
  "threshold_input_1_5_non_informative",
   label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95,0.95,0.95), 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '2x2' & input.prior_information=='Non-informative'",
matrixInput(
  "threshold_input_2_2_non_informative",
   label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.95,0.95,0.9,0.95), 2, 2, byrow=TRUE, dimnames = list(c("A2","A1"), c("B1", "B2"))), 
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  ## For informative prior
  conditionalPanel(
      condition = "input.lattice == '1x2' & input.prior_information=='Informative'",
matrixInput(
  "threshold_input_1_2_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95), 1, 2, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x3' & input.prior_information=='Informative'",
matrixInput(
  "threshold_input_1_3_informative",
 label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95), 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '1x4' & input.prior_information=='Informative'",
matrixInput(
  "threshold_input_1_4_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95,0.95), 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
   conditionalPanel(
      condition = "input.lattice == '1x5' & input.prior_information=='Informative'",
matrixInput(
  "threshold_input_1_5_informative",
  label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95,0.95,0.95), 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.lattice == '2x2' & input.prior_information=='Informative'",
matrixInput(
  "threshold_input_2_2_informative",
 label="Please input the thresholds for toxicity control (Default value is 0.9 for dose 1 and 0.95 for other doses) :",
  value = matrix(c(0.9,0.95,0.95,0.95), 2, 2, byrow=TRUE, dimnames = list(c("A2","A1"), c("B1", "B2"))), 
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
 # Input posterior mean factor.
  # conditionalPanel(
  #     condition = "input.action == 'Conducting'", # In the context of clinical trials, we exclusively establish the posterior mean factor; this practice does not extend to the execution of simulations, as the results from these simulations are intended for comparison with alternative designs, including the 3+3 and BOIN. 
  #    selectInput("BOLD_mean_factor", label="What is the posterior mean factor m? (The posterior mean DLT rate of MTD candidates cannot be greater than [1+m] x target, with default value m=0.4)", selected = 0.4, BOLD_mean_factor_list)), 
  # Input stage number.
  conditionalPanel(
      condition = "input.action == 'Conducting'", 
      selectInput("stage_input", label="What is the current stage number? (The stage for combination-drug trial must begin with 1 and continue thereafter)", selected = 1, stage_list)), # The default is stage 1.
   # Input current dose level being administered.
  conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '1x2'",
    selectInput("cur_b_1_2", "What is the dose level being currently administered?", selected =1, dose_level_a1_b2)
    ),
  conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '1x3'",
    selectInput("cur_b_1_3", "What is the dose level being currently administered?", selected =1, dose_level_a1_b3)
    ),
 conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '1x4'",
    selectInput("cur_b_1_4", "What is the dose level being currently administered?", selected =1, dose_level_a1_b4)
    ),
  conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '1x5'",
    selectInput("cur_b_1_5", "What is the dose level being currently administered?", selected =1, dose_level_a1_b5)
    ),
   conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '2x2'",
    selectInput("cur_a_2_2", "What is the dose level of drug A being currently administered?", selected =1, dose_level_a2_b2_a)
    ),
   conditionalPanel(
    condition = "input.action == 'Conducting' & input.lattice == '2x2'",
    selectInput("cur_b_2_2", "What is the dose level of drug B being currently administered?", selected =1, dose_level_a2_b2_b)
    ), 
 # Input accumulated numbers of treated patients in MTD trial.
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x2'",
matrixInput(
  "n_input_MTD_1_2",
  label="Please input the accumulated numbers of treated patients in MTD trial (Not including those from backfilled dose levels) :",
  value = matrix(c(3,0), 1, 2, dimnames = list("A1", c("B1", "B2"))), # The first n cannot be zero, otherwise there will be error with the weighting factors in PAVA.
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
   conditionalPanel(      
    condition = "input.action == 'Conducting' & input.lattice == '1x3'",
matrixInput(
  "n_input_MTD_1_3",
  label="Please input the accumulated numbers of treated patients in MTD trial (Not including those from backfilled dose levels) :",
  value = matrix(c(3,0,0), 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x4'",
matrixInput(
  "n_input_MTD_1_4",
  label="Please input the accumulated numbers of treated patients in MTD trial (Not including those from backfilled dose levels) :",
  value = matrix(c(3,0,0,0), 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x5'",
matrixInput(
  "n_input_MTD_1_5",
  label="Please input the accumulated numbers of treated patients in MTD trial (Not including those from backfilled dose levels) :",
  value = matrix(c(3,0,0,0,0), 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '2x2'",
matrixInput(
  "n_input_MTD_2_2",
  label="Please input the accumulated numbers of treated patients in MTD trial (Not including those from backfilled dose levels) :",
  value = matrix(c(0,0,3,0), 2, 2, byrow=TRUE, dimnames = list(c("A2", "A1"), c("B1", "B2"))), # Note that n of A1B1 is 3, which appears at the 3rd place in the vector rather than the 1st place.
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
# Input accumulated numbers of treated patients in Backfill trial.
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x2'",
matrixInput(
  "n_input_Backfill_1_2",
  label="Please input the accumulated numbers of treated patients in Backfill trial (Not including those from MTD trial dose levels) :",
  value = matrix(c(0,0), 1, 2, dimnames = list("A1", c("B1", "B2"))), 
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
   conditionalPanel(      
    condition = "input.action == 'Conducting' & input.lattice == '1x3'",
matrixInput(
  "n_input_Backfill_1_3",
  label="Please input the accumulated numbers of treated patients in Backfill trial (Not including those from MTD trial dose levels) :",
  value = matrix(c(0,0,0), 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x4'",
matrixInput(
  "n_input_Backfill_1_4",
  label="Please input the accumulated numbers of treated patients in Backfill trial (Not including those from MTD trial dose levels) :",
  value = matrix(c(0,0,0,0), 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x5'",
matrixInput(
  "n_input_Backfill_1_5",
  label="Please input the accumulated numbers of treated patients in Backfill trial (Not including those from MTD trial dose levels) :",
  value = matrix(c(0,0,0,0,0), 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '2x2'",
matrixInput(
  "n_input_Backfill_2_2",
  label="Please input the accumulated numbers of treated patients in Backfill trial (Not including those from MTD trial dose levels) :",
  value = matrix(c(0,0,3,0), 2, 2, byrow=TRUE, dimnames = list(c("A2", "A1"), c("B1", "B2"))), # Note that n of A1B1 is 3, which appears at the 3rd place in the vector rather than the 1st place.
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  # Input accumulated numbers of DLTs in both MTD and Backfill trial.
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x2'",
matrixInput(
  "x_toxic_input_1_2",
  label="Please input the number of accumulated DLTs (Including both MTD and Backfill trials) :",
  value = matrix(0, 1, 2, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x3'",
matrixInput(
  "x_toxic_input_1_3",
  label="Please input the number of accumulated DLTs (Including both MTD and Backfill trials) :",
  value = matrix(0, 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x4'",
matrixInput(
  "x_toxic_input_1_4",
  label="Please input the number of accumulated DLTs (Including both MTD and Backfill trials) :",
  value = matrix(0, 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '1x5'",
matrixInput(
  "x_toxic_input_1_5",
  label="Please input the number of accumulated DLTs (Including both MTD and Backfill trials) :",
  value = matrix(0, 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.lattice == '2x2'",
matrixInput(
  "x_toxic_input_2_2",
  label="Please input the number of accumulated DLTs (Including both MTD and Backfill trials) :",
  value = matrix(0, 2, 2, dimnames = list(c("A2", "A1"), c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
# Input accumulated numbers of activity in MTD trial.
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.backfill_option=='Yes' & input.lattice == '1x2'",
matrixInput(
  "x_efficacy_input_1_2",
  label="Please input the number of accumulated activities (Including both MTD and Backfill trials) :",
  value = matrix(0, 1, 2, dimnames = list("A1", c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.backfill_option=='Yes' & input.lattice == '1x3'",
matrixInput(
  "x_efficacy_input_1_3",
  label="Please input the number of accumulated activities (Including both MTD and Backfill trials) :",
  value = matrix(0, 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.backfill_option=='Yes' & input.lattice == '1x4'",
matrixInput(
  "x_efficacy_input_1_4",
  label="Please input the number of accumulated activities (Including both MTD and Backfill trials) :",
  value = matrix(0, 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.backfill_option=='Yes' & input.lattice == '1x5'",
matrixInput(
  "x_efficacy_input_1_5",
  label="Please input the number of accumulated activities (Including both MTD and Backfill trials) :",
  value = matrix(0, 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Conducting' & input.backfill_option=='Yes' & input.lattice == '2x2'",
matrixInput(
  "x_efficacy_input_2_2",
  label="Please input the number of accumulated activities (Including both MTD and Backfill trials) :",
  value = matrix(0, 2, 2, dimnames = list(c("A2", "A1"), c("B1", "B2"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
# Input true DLT rates for simulation.
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.lattice == '1x2'",
matrixInput(
  "dlt_true_input_1_2",
  label="Please input the non-descending true DLT rates for simulation (Target rate may be used as the default value for the assumed MTD):",
  value = matrix(c(0.25,0.4), 1, 2, dimnames = list("A1", c("B1", "B2"))),   rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.lattice == '1x3'",
matrixInput(
  "dlt_true_input_1_3",
  label="Please input the non-descending true DLT rates for simulation (Target rate may be used as the default value for the assumed MTD):",
  value = matrix(c(0.15,0.25,0.4), 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.lattice == '1x4'",
matrixInput(
  "dlt_true_input_1_4",
  label="Please input the non-descending true DLT rates for simulation (Target rate may be used as the default value for the assumed MTD):",
  value = matrix(c(0.05,0.15,0.25,0.4), 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.lattice == '1x5'",
matrixInput(
  "dlt_true_input_1_5",
  label="Please input the non-descending true DLT rates for simulation (Target rate may be used as the default value for the assumed MTD):",
  value = matrix(c(0.05,0.15,0.25,0.4,0.5), 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.lattice == '2x2'",
matrixInput(
  "dlt_true_input_2_2",
  label="Please input the non-descending true DLT rates for simulation (Target rate may be used as the default value for the assumed MTD):",
  value = matrix(c(0.15,0.25,0.4,0.5), 2, 2, byrow=TRUE, dimnames = list(c("A2", "A1"), c("B1", "B2"))), 
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
 # Input true activity rates for simulation.
  conditionalPanel(
      condition = "input.action == 'Simulation' & input.backfill_option=='Yes' & input.lattice == '1x2'",
matrixInput(
  "efficacy_true_input_1_2",
  label="Please input the non-descending true activity rates for simulation (Minimum acceptable toxicity rate may be used as the default value for the assumed OBD and higher dose levels with a plateau):",
  value = matrix(c(0.3,0.3), 1, 2, dimnames = list("A1", c("B1", "B2"))),   rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
    conditionalPanel(
      condition = "input.action == 'Simulation' & input.backfill_option=='Yes' & input.lattice == '1x3'",
matrixInput(
  "efficacy_true_input_1_3",
  label="Please input the non-descending true activity rates for simulation (Minimum acceptable toxicity rate may be used as the default value for the assumed OBD and higher dose levels with a plateau):",
  value = matrix(c(0.3,0.3,0.3), 1, 3, dimnames = list("A1", c("B1", "B2", "B3"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
 conditionalPanel(
      condition = "input.action == 'Simulation' & input.backfill_option=='Yes' & input.lattice == '1x4'",
matrixInput(
  "efficacy_true_input_1_4",
  label="Please input the non-descending true activity rates for simulation (Minimum acceptable toxicity rate may be used as the default value for the assumed OBD and higher dose levels with a plateau):",
  value = matrix(c(0.2,0.3,0.3,0.3), 1, 4, dimnames = list("A1", c("B1", "B2", "B3", "B4"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
 conditionalPanel(
      condition = "input.action == 'Simulation' & input.backfill_option=='Yes' & input.lattice == '1x5'",
matrixInput(
  "efficacy_true_input_1_5",
  label="Please input the non-descending true activity rates for simulation (Minimum acceptable toxicity rate may be used as the default value for the assumed OBD and higher dose levels with a plateau):",
  value = matrix(c(0.2,0.3,0.3,0.3,0.3), 1, 5, dimnames = list("A1", c("B1", "B2", "B3", "B4", "B5"))),
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
 conditionalPanel(
      condition = "input.action == 'Simulation' & input.backfill_option=='Yes' & input.lattice == '2x2'",
matrixInput(
  "efficacy_true_input_2_2",
  label="Please input the non-descending true activity rates for simulation (Minimum acceptable toxicity rate may be used as the default value for the assumed OBD and higher dose levels with a plateau):",
  value = matrix(c(0.3,0.3,0.3,0.3), 2, 2, byrow=TRUE, dimnames = list(c("A2", "A1"), c("B1", "B2"))), 
  rows = list(names = TRUE),
  cols = list(names = TRUE)
)),
# Input the number of simulation runs.
  conditionalPanel(
     condition = "input.action == 'Simulation'", 
     selectInput("simulation_runs", label="What is the number of simulation runs? (Default value is 1,000)", selected = 1000, simulation_runs_list)),
  # Button of action (running).
  actionButton("Submit", "Start"),
   verbatimTextOutput("result")
  )
 )
```
# Shiny server program
```{r server, message=FALSE, warning=FALSE}
server <- function(input, output)
 { #1
  result <- eventReactive(input$Submit, {
  my_function(as.character(input$action), as.character(input$lattice), as.character(input$backfill_option), as.numeric(input$p_target), as.numeric(input$p_target_efficacy), as.numeric(input$ppat_selection), as.character(input$backfill_strategy), as.numeric(input$CPAT_efficacy_threshold_for_backfill), as.numeric(input$efficacy_trade_off), as.numeric(input$n_stop_total), as.numeric(input$n_stop_BOLD_1), as.numeric(input$n_stop_BOLD), as.character(input$prior_information), as.matrix(input$dlt_prior_input_1_2), as.matrix(input$dlt_prior_input_1_3), as.matrix(input$dlt_prior_input_1_4), as.matrix(input$dlt_prior_input_1_5), as.matrix(input$dlt_prior_input_2_2), as.numeric(input$cur_b_1_2), as.numeric(input$cur_b_1_3), as.numeric(input$cur_b_1_4), as.numeric(input$cur_b_1_5), as.numeric(input$cur_a_2_2), as.numeric(input$cur_b_2_2), as.numeric(input$n_p), as.matrix(input$n_input_MTD_1_2), as.matrix(input$n_input_MTD_1_3), as.matrix(input$n_input_MTD_1_4), as.matrix(input$n_input_MTD_1_5), as.matrix(input$n_input_MTD_2_2), as.matrix(input$n_input_Backfill_1_2), as.matrix(input$n_input_Backfill_1_3), as.matrix(input$n_input_Backfill_1_4), as.matrix(input$n_input_Backfill_1_5), as.matrix(input$n_input_Backfill_2_2), as.matrix(input$x_toxic_input_1_2), as.matrix(input$x_toxic_input_1_3), as.matrix(input$x_toxic_input_1_4), as.matrix(input$x_toxic_input_1_5), as.matrix(input$x_toxic_input_2_2),  as.matrix(input$x_efficacy_input_1_2), as.matrix(input$x_efficacy_input_1_3), as.matrix(input$x_efficacy_input_1_4), as.matrix(input$x_efficacy_input_1_5), as.matrix(input$x_efficacy_input_2_2), as.matrix(input$pess_input_1_2), as.matrix(input$pess_input_1_3), as.matrix(input$pess_input_1_4), as.matrix(input$pess_input_1_5), as.matrix(input$pess_input_2_2), as.matrix(input$threshold_input_1_2_non_informative), as.matrix(input$threshold_input_1_3_non_informative), as.matrix(input$threshold_input_1_4_non_informative), as.matrix(input$threshold_input_1_5_non_informative), as.matrix(input$threshold_input_2_2_non_informative), as.matrix(input$threshold_input_1_2_informative), as.matrix(input$threshold_input_1_3_informative), as.matrix(input$threshold_input_1_4_informative), as.matrix(input$threshold_input_1_5_informative), as.matrix(input$threshold_input_2_2_informative),as.numeric(input$stage_input), as.matrix(input$dlt_true_input_1_2), as.matrix(input$dlt_true_input_1_3), as.matrix(input$dlt_true_input_1_4), as.matrix(input$dlt_true_input_1_5), as.matrix(input$dlt_true_input_2_2), as.matrix(input$efficacy_true_input_1_2), as.matrix(input$efficacy_true_input_1_3), as.matrix(input$efficacy_true_input_1_4), as.matrix(input$efficacy_true_input_1_5), as.matrix(input$efficacy_true_input_2_2), as.numeric(input$simulation_runs))
    }) 
  # Output the result
   output$result <- renderPrint({
      result()})
} #1
```
# Shiny App
```{r shiny_app, message=FALSE, warning=FALSE}
shinyApp(ui, server)
```
